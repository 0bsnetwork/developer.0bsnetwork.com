{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the 0bsNetwork Developer Hub You'll find comprehensive guides and documentation to help you start working with the 0bsnetwork as quickly as possible, as well as support if you get stuck. Let's jump right in! This developer site is written with the \"Dev Without Blockchain Experience\" in mind, and you shouldn't need to do much blockchain research before diving in. Our tools are standard tools that you will already be familiar with and we support enough languages and platforms for most developers to be able to get stuck in straight away and learn the blockchain parts as you go. You dont always need to know the minute cryptographic details of every operation so we have mostly left this information out, however it is available should you need it! Experienced blockchain developers can jump right to the relevant section, the below links may help. For non-developers / non-technial, please visit our website or docs site here; https://docs.0bsnetwork.com/ Quick Links Components and Services - Key Players Data Service Docs JavaScript Development Contact Info Telegram Group: @0bsdev - Ask your development questions here Dev Support: dev@0bsnetwork.com Please let us know if you find any errors or confusing parts of the documentation!","title":"Home"},{"location":"#welcome-to-the-0bsnetwork-developer-hub","text":"You'll find comprehensive guides and documentation to help you start working with the 0bsnetwork as quickly as possible, as well as support if you get stuck. Let's jump right in! This developer site is written with the \"Dev Without Blockchain Experience\" in mind, and you shouldn't need to do much blockchain research before diving in. Our tools are standard tools that you will already be familiar with and we support enough languages and platforms for most developers to be able to get stuck in straight away and learn the blockchain parts as you go. You dont always need to know the minute cryptographic details of every operation so we have mostly left this information out, however it is available should you need it! Experienced blockchain developers can jump right to the relevant section, the below links may help. For non-developers / non-technial, please visit our website or docs site here; https://docs.0bsnetwork.com/","title":"Welcome to the 0bsNetwork Developer Hub"},{"location":"#quick-links","text":"Components and Services - Key Players Data Service Docs JavaScript Development","title":"Quick Links"},{"location":"#contact-info","text":"Telegram Group: @0bsdev - Ask your development questions here Dev Support: dev@0bsnetwork.com Please let us know if you find any errors or confusing parts of the documentation!","title":"Contact Info"},{"location":"about/","text":"About 0bsNetwork 0bsNetwork is a LPOS - Leasing Proof of Stake BlockChain, this differs from something like Bitcoin or Ethereum, as rather than having miners producing proof of work, for example, generating hashes to solve a challenge, a stake of coins instead secures the network. In our case, the coin is ZBS coin. Running a full node on the network requires that the node has a 'generating balance' of at least 1000 ZBS coins, these can either be in the nodes wallet, or leased to the node. Once your node has established 1000 ZBS generating balance it will begin generating blocks. The more coins you have, the more often you will generate a block. Nodes that generate blocks recieve the transaction fees as the reward (As opposed to the block reward in bitcoin) Our network is entirely pre-mined, in a good way, we have 51m coins issued in the genesis block, so the supply will never change. You can create a token on our platform right from the wallet (Or using a library or API if you wish) and set its supply, details etc. These are also refferred to 'assets' within the code and transactions. Main / Test Confrimations < More details about chain from a dev POV> Without further ado, lets move onto getting started where we explain all the parts of the system, and what you need to get up and running","title":"About 0bsNetwork"},{"location":"about/#about-0bsnetwork","text":"0bsNetwork is a LPOS - Leasing Proof of Stake BlockChain, this differs from something like Bitcoin or Ethereum, as rather than having miners producing proof of work, for example, generating hashes to solve a challenge, a stake of coins instead secures the network. In our case, the coin is ZBS coin. Running a full node on the network requires that the node has a 'generating balance' of at least 1000 ZBS coins, these can either be in the nodes wallet, or leased to the node. Once your node has established 1000 ZBS generating balance it will begin generating blocks. The more coins you have, the more often you will generate a block. Nodes that generate blocks recieve the transaction fees as the reward (As opposed to the block reward in bitcoin) Our network is entirely pre-mined, in a good way, we have 51m coins issued in the genesis block, so the supply will never change. You can create a token on our platform right from the wallet (Or using a library or API if you wish) and set its supply, details etc. These are also refferred to 'assets' within the code and transactions. Main / Test Confrimations < More details about chain from a dev POV> Without further ado, lets move onto getting started where we explain all the parts of the system, and what you need to get up and running","title":"About 0bsNetwork"},{"location":"componentsandservices/","text":"Introduction This section will explain all the parts of our platform from a developers point of view. To check the status of any of our central services you can visit https://status.0bsnetwork.com/ And you can also run any of these services yourself. Key Players Full Node This is the 'core' of our platform. Each node processes transactions into blocks. A node contains a wallet. A collection of nodes create ... The Network We have 2 networks, MainNet and TestNet. Testnet is where all development can take place as the coins are worthless, and you can afford to make mistakes. You can think of MainNet as 'Production'. For MainNet you can replace testnet- in all the URLs in this documentation. Full Node API Our full node exposes an API for; - Transactions (Creating and Broadcasting) - Node, Network and Address information - Node operation and configuration However, in some cases, to get aggregate data such as data from data transactions, you are better using the data service API listed below. Client / Wallet A hosted version of a wallet for those that do not run a full node, it connects to our full node to get its information by default but you can also point it at your own node. Here you can view your balances, create tokens, Send and receive, Trade and view blockchain info https://client.testnet-0bsnetwork.com Faucet A 'Faucet' allows you to obtain free testnet coins in order to build your project. You can go to https://explorer.0bsnetwork.com/testnet/faucet and simply enter your address to obtain 250 free testnet coins Block Explorer Our block explorer lists all the blocks within our network, you can drill down to transaction level and see all the details. This is useful to look into transactions as you are developing to check you get the expected result. https://explorer.0bsnetwork.com (Select testnet from dropdown) IDE / Smart Contracts Our smart contracts are written in a language called RIDE and can be applied to either an Asset to create a 'Smart Asset' or an account (Address) to create a 'Smart Account' This enables us to create behaviours on a token (Trading restraints for example) or an account (Multi Signature) You can have a play and use our REPL at the below link. There's also some sample scripts and you can deploy right from the IDE page. https://ide.0bsnetwork.com Data Service This is a nice fast rest API that exposes information from our blockchain such as; Data from data transactions (Ability to query and filter) Information about Assets Trading Information (Stats, Prices, Volume) See the Data Service API Section for details Matcher The matcher is our trading 'engine' taking orders for sells and buys and matching them up, the matcher hosts the orderbook and also has an API https://matcher.testnet-0bsnetwork.com Libraries We have a library for many differnet languages and platforms and more are being added every day. The libraries are firstly an interface to the Node and Matcher API, with the addition of the ability to sign transactions and broadcast them to the node (Signing transactions manually is a little tricky) 0bsLink 0bsLink is a browser add-on / extension that is essentially a wallet, however it comes with an API so you can build a wabpage to interact with this extension, to build 0bsNetwork powered web applicaitons witout having to deal with any of the complexity. IDE & REPL This is where you can code and test smart contracts, as well as use our REPL.. This tool comes with plenty of examples and help, so dive right in and check it out. Always worth having this open in a tab during development! https://ide.testnet-0bsnetwork.com","title":"Components and Services"},{"location":"componentsandservices/#introduction","text":"This section will explain all the parts of our platform from a developers point of view. To check the status of any of our central services you can visit https://status.0bsnetwork.com/ And you can also run any of these services yourself.","title":"Introduction"},{"location":"componentsandservices/#key-players","text":"","title":"Key Players"},{"location":"componentsandservices/#full-node","text":"This is the 'core' of our platform. Each node processes transactions into blocks. A node contains a wallet. A collection of nodes create ...","title":"Full Node"},{"location":"componentsandservices/#the-network","text":"We have 2 networks, MainNet and TestNet. Testnet is where all development can take place as the coins are worthless, and you can afford to make mistakes. You can think of MainNet as 'Production'. For MainNet you can replace testnet- in all the URLs in this documentation.","title":"The Network"},{"location":"componentsandservices/#full-node-api","text":"Our full node exposes an API for; - Transactions (Creating and Broadcasting) - Node, Network and Address information - Node operation and configuration However, in some cases, to get aggregate data such as data from data transactions, you are better using the data service API listed below.","title":"Full Node API"},{"location":"componentsandservices/#client-wallet","text":"A hosted version of a wallet for those that do not run a full node, it connects to our full node to get its information by default but you can also point it at your own node. Here you can view your balances, create tokens, Send and receive, Trade and view blockchain info https://client.testnet-0bsnetwork.com","title":"Client / Wallet"},{"location":"componentsandservices/#faucet","text":"A 'Faucet' allows you to obtain free testnet coins in order to build your project. You can go to https://explorer.0bsnetwork.com/testnet/faucet and simply enter your address to obtain 250 free testnet coins","title":"Faucet"},{"location":"componentsandservices/#block-explorer","text":"Our block explorer lists all the blocks within our network, you can drill down to transaction level and see all the details. This is useful to look into transactions as you are developing to check you get the expected result. https://explorer.0bsnetwork.com (Select testnet from dropdown)","title":"Block Explorer"},{"location":"componentsandservices/#ide-smart-contracts","text":"Our smart contracts are written in a language called RIDE and can be applied to either an Asset to create a 'Smart Asset' or an account (Address) to create a 'Smart Account' This enables us to create behaviours on a token (Trading restraints for example) or an account (Multi Signature) You can have a play and use our REPL at the below link. There's also some sample scripts and you can deploy right from the IDE page. https://ide.0bsnetwork.com","title":"IDE / Smart Contracts"},{"location":"componentsandservices/#data-service","text":"This is a nice fast rest API that exposes information from our blockchain such as; Data from data transactions (Ability to query and filter) Information about Assets Trading Information (Stats, Prices, Volume) See the Data Service API Section for details","title":"Data Service"},{"location":"componentsandservices/#matcher","text":"The matcher is our trading 'engine' taking orders for sells and buys and matching them up, the matcher hosts the orderbook and also has an API https://matcher.testnet-0bsnetwork.com","title":"Matcher"},{"location":"componentsandservices/#libraries","text":"We have a library for many differnet languages and platforms and more are being added every day. The libraries are firstly an interface to the Node and Matcher API, with the addition of the ability to sign transactions and broadcast them to the node (Signing transactions manually is a little tricky)","title":"Libraries"},{"location":"componentsandservices/#0bslink","text":"0bsLink is a browser add-on / extension that is essentially a wallet, however it comes with an API so you can build a wabpage to interact with this extension, to build 0bsNetwork powered web applicaitons witout having to deal with any of the complexity.","title":"0bsLink"},{"location":"componentsandservices/#ide-repl","text":"This is where you can code and test smart contracts, as well as use our REPL.. This tool comes with plenty of examples and help, so dive right in and check it out. Always worth having this open in a tab during development! https://ide.testnet-0bsnetwork.com","title":"IDE &amp; REPL"},{"location":"cs/","text":"","title":"C# Library"},{"location":"dataservice/","text":"Data Service API Our data service API stores information about the blockchain, data, and trading. We host a public version of the API, and if you need more limits (Public API limits number of results in 1 page) you can also run your own dockerised version of this API. You can use this API to, for example, get a list of all data submitted on an account within 24 hours. It's much quicker and easier than using the Node API where you would have to pull a list of all blocks and transactions and locate the right data. The documentation for the API is located at; https://api.testnet-0bsnetwork.com/docs Below is a demonstration of using the API Demo Here's a quick demo of our data API. This is a small docker container that runs alongside a node (NodeJS + PostGreSQL) and either you could run your own if your data querying requirements are large, or use our public one for smaller queries (There's smaller limits in place on the public one) So, Lets say we want to get all data transactions for a particular ID, in this case, I've been saving data from my orange tree, which has a 'plantId' of '23456-f344f3' So the filters we have available on the data transaction endpoint are as follows sender - public address of the data transaction sender timeStart - Start Time (e.g. 2019-05-29T03:51:05.303Z) or just date timeEnd - End Time (As Above) key - Filter by Key type - Filter by data type value - Filer by value after - Insert the previous pages cursor (lastCursor) to get the next set of records (depending on limit) limit - How many to return (Default 100 Max 1000) So, if we want to get all data transactions on the 27th May for my plant, we can query like this (Lets say we want them in pages of 5) .. Go ahead and click the URL to try it! https://api.testnet-0bsnetwork.com/v0/transactions/data?key=plantid&type=string&value=23456-f344f3&timeStart=2019-05-27&limit=5 We can see we get 5 results, and only data for that plant based on its plantId, we can see the Temp, Humidity and Soil Moisture. If we now want to get the next 5 records, we take the 'lastCursor' value of the response, and use it for the 'after' paramter in the next call https://api.testnet-0bsnetwork.com/v0/transactions/data?key=plantid&type=string&value=23456-f344f3&timeStart=2019-05-27&limit=5&after=MjAxOS0wNS0yOVQwNDo1MTowNS42NzJaOjoyZnA2OUJEVjJ3M0tjZ1h0eWozdGJrSER1b3g0NnNtdDFUOUNKcWh3NGtDajo6ZGVzYw== This now gives us the next 5 records.. we could continue this until we react the end of the data (response.data.count < 5) Note: For UI apps its best to only request what the user is viewing on the screen and make subsequent calls to update, most grids support this style of paging. For back end, you can request in chunks of 1000, or run your own data service to increase this limit. Finally, all data is always returned with its transactionID, so any transaction can be verififed on the blockchain using any or your own node!","title":"Data Service API"},{"location":"dataservice/#data-service-api","text":"Our data service API stores information about the blockchain, data, and trading. We host a public version of the API, and if you need more limits (Public API limits number of results in 1 page) you can also run your own dockerised version of this API. You can use this API to, for example, get a list of all data submitted on an account within 24 hours. It's much quicker and easier than using the Node API where you would have to pull a list of all blocks and transactions and locate the right data. The documentation for the API is located at; https://api.testnet-0bsnetwork.com/docs Below is a demonstration of using the API","title":"Data Service API"},{"location":"dataservice/#demo","text":"Here's a quick demo of our data API. This is a small docker container that runs alongside a node (NodeJS + PostGreSQL) and either you could run your own if your data querying requirements are large, or use our public one for smaller queries (There's smaller limits in place on the public one) So, Lets say we want to get all data transactions for a particular ID, in this case, I've been saving data from my orange tree, which has a 'plantId' of '23456-f344f3' So the filters we have available on the data transaction endpoint are as follows sender - public address of the data transaction sender timeStart - Start Time (e.g. 2019-05-29T03:51:05.303Z) or just date timeEnd - End Time (As Above) key - Filter by Key type - Filter by data type value - Filer by value after - Insert the previous pages cursor (lastCursor) to get the next set of records (depending on limit) limit - How many to return (Default 100 Max 1000) So, if we want to get all data transactions on the 27th May for my plant, we can query like this (Lets say we want them in pages of 5) .. Go ahead and click the URL to try it! https://api.testnet-0bsnetwork.com/v0/transactions/data?key=plantid&type=string&value=23456-f344f3&timeStart=2019-05-27&limit=5 We can see we get 5 results, and only data for that plant based on its plantId, we can see the Temp, Humidity and Soil Moisture. If we now want to get the next 5 records, we take the 'lastCursor' value of the response, and use it for the 'after' paramter in the next call https://api.testnet-0bsnetwork.com/v0/transactions/data?key=plantid&type=string&value=23456-f344f3&timeStart=2019-05-27&limit=5&after=MjAxOS0wNS0yOVQwNDo1MTowNS42NzJaOjoyZnA2OUJEVjJ3M0tjZ1h0eWozdGJrSER1b3g0NnNtdDFUOUNKcWh3NGtDajo6ZGVzYw== This now gives us the next 5 records.. we could continue this until we react the end of the data (response.data.count < 5) Note: For UI apps its best to only request what the user is viewing on the screen and make subsequent calls to update, most grids support this style of paging. For back end, you can request in chunks of 1000, or run your own data service to increase this limit. Finally, all data is always returned with its transactionID, so any transaction can be verififed on the blockchain using any or your own node!","title":"Demo"},{"location":"fullnode/","text":"Full Node Operation Voting","title":"Full Node Operation"},{"location":"fullnode/#full-node-operation","text":"","title":"Full Node Operation"},{"location":"fullnode/#voting","text":"","title":"Voting"},{"location":"glossary/","text":"","title":"Glossary"},{"location":"java/","text":"","title":"Java Library"},{"location":"javascript/","text":"","title":"Javascript Libraries"},{"location":"link/","text":"","title":"0bsLink"},{"location":"nodeapi/","text":"Full Node API The full node exposes an API that allows you to manage the node, get information about its status, get information about the blockchain, and interact with the blockchain. The node comes with its own API documentation which goes some way to explain the features and functions and that can be found on port 7431 on your own node, or you can use our public node API here; https://node1.testnet-0bsnetwork.com To enable the API on your own node, you need to enable it, set its API key, and ensure its listening and exposed on the firewall. Within your nodes configuration file, find the rest-api section and set; enable = yes bind-address = Your IP or 0.0.0.0 to listen on all IPs double check the port its 7431 for testnet and 7441 for mainnet and open up that port on your firewall (ufw allow 7431) Initially set api-key-hash to some gibberish to protect your API, and we can set it properly in the next step. rest-api { enable = yes bind-address = \"127.0.0.1\" port = 7431 api-key-hash = \"86GJVSoboK12zXHYJFzoucAKaFS1yyXA2NztWSt9tGiX\" } Once you restart your node, you should be able to access the swagger interface at http://yournode:7431 Now we need to setup the API key, and the API conveniently has a feature to do that, open up the 'utils' section on the API page, and find; utils/hash/secure Enter your desired API key and hit 'try it out' and it should give you a hash in response. Paste that into the api-key-hash in your config file and restart your node again, you can now use the API key in API calls that require it. This API key gives you access to features on your node using the nodes wallet, for example, you can have the node sign a transaction Signing Transactions on the Node You can send a transaction to your node to sign, and it will be signed using the private key of the nodes wallet (Ensure the nodes wallet has funds... You can get its address from the nodes API /addresses endpoint) The steps to do this are as below. Note: Its not possible to sign transactions on our public nodes as the node does these oprations using its own private key Obtain the correct JSON transaction format from Transactions POST the json to the /transactions/sign endpoint (Including your API key in the header X-API-Key) The node returns a signed transaction POST the signed transaction to the nodes /transactions/broadcast endpoint Below is an example of the transactions/sign endpoint curl -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' --header 'X-API-Key: myapikey' -d '{ \\ \"senderPublicKey\":\"4c5K4kGeRdrnSYZ9wngQKSozikVgfxmDEuViirsyUHwd\", \\ \"amount\":110000000 \\ fee\":500000, \\ \"type\":4, \\ \"version\":2, \\ \"attachment\":\"\", \\ \"sender\":\"3MyT3r1S8xvKtiKnLgVNNiSAiQdnMbffBQy\", \\ \"feeAssetId\":null, \\ \"proofs\":[\"2KFbYWi9BJwDG9dbiJQzC9qJPpu4Ug8Ybs331fQbX9FAkEpEtrj9DKvwNG7cb2m98DV6NCoKH4MBVtGGFsnQWPV6\"], \\ \"assetId\":null, // If we are sending an asset, null for ZBS \\ \"recipient\":\"3MqEisFsWdhvDMAKBwZzZv4niVsfJJtxcaw\", \\ \"feeAsset\":null \\ }' 'https://node1.testnet-0bsnetwork.com/transactions/sign' Of course this is not ideal for many situations, and you need to sign the transaction on the client side, and only use the node to broadcast the transaction. Our libraries help with this, or check out Transactions For more details on manually signing transactions. Matcher API Matcher also has an API to create orders, and get orderbook information. The documentation for this is hosted by the matcher at; https://matcher.testnet-0bsnetwork.com","title":"Full Node REST API"},{"location":"nodeapi/#full-node-api","text":"The full node exposes an API that allows you to manage the node, get information about its status, get information about the blockchain, and interact with the blockchain. The node comes with its own API documentation which goes some way to explain the features and functions and that can be found on port 7431 on your own node, or you can use our public node API here; https://node1.testnet-0bsnetwork.com To enable the API on your own node, you need to enable it, set its API key, and ensure its listening and exposed on the firewall. Within your nodes configuration file, find the rest-api section and set; enable = yes bind-address = Your IP or 0.0.0.0 to listen on all IPs double check the port its 7431 for testnet and 7441 for mainnet and open up that port on your firewall (ufw allow 7431) Initially set api-key-hash to some gibberish to protect your API, and we can set it properly in the next step. rest-api { enable = yes bind-address = \"127.0.0.1\" port = 7431 api-key-hash = \"86GJVSoboK12zXHYJFzoucAKaFS1yyXA2NztWSt9tGiX\" } Once you restart your node, you should be able to access the swagger interface at http://yournode:7431 Now we need to setup the API key, and the API conveniently has a feature to do that, open up the 'utils' section on the API page, and find; utils/hash/secure Enter your desired API key and hit 'try it out' and it should give you a hash in response. Paste that into the api-key-hash in your config file and restart your node again, you can now use the API key in API calls that require it. This API key gives you access to features on your node using the nodes wallet, for example, you can have the node sign a transaction","title":"Full Node API"},{"location":"nodeapi/#signing-transactions-on-the-node","text":"You can send a transaction to your node to sign, and it will be signed using the private key of the nodes wallet (Ensure the nodes wallet has funds... You can get its address from the nodes API /addresses endpoint) The steps to do this are as below. Note: Its not possible to sign transactions on our public nodes as the node does these oprations using its own private key Obtain the correct JSON transaction format from Transactions POST the json to the /transactions/sign endpoint (Including your API key in the header X-API-Key) The node returns a signed transaction POST the signed transaction to the nodes /transactions/broadcast endpoint Below is an example of the transactions/sign endpoint curl -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' --header 'X-API-Key: myapikey' -d '{ \\ \"senderPublicKey\":\"4c5K4kGeRdrnSYZ9wngQKSozikVgfxmDEuViirsyUHwd\", \\ \"amount\":110000000 \\ fee\":500000, \\ \"type\":4, \\ \"version\":2, \\ \"attachment\":\"\", \\ \"sender\":\"3MyT3r1S8xvKtiKnLgVNNiSAiQdnMbffBQy\", \\ \"feeAssetId\":null, \\ \"proofs\":[\"2KFbYWi9BJwDG9dbiJQzC9qJPpu4Ug8Ybs331fQbX9FAkEpEtrj9DKvwNG7cb2m98DV6NCoKH4MBVtGGFsnQWPV6\"], \\ \"assetId\":null, // If we are sending an asset, null for ZBS \\ \"recipient\":\"3MqEisFsWdhvDMAKBwZzZv4niVsfJJtxcaw\", \\ \"feeAsset\":null \\ }' 'https://node1.testnet-0bsnetwork.com/transactions/sign' Of course this is not ideal for many situations, and you need to sign the transaction on the client side, and only use the node to broadcast the transaction. Our libraries help with this, or check out Transactions For more details on manually signing transactions.","title":"Signing Transactions on the Node"},{"location":"nodeapi/#matcher-api","text":"Matcher also has an API to create orders, and get orderbook information. The documentation for this is hosted by the matcher at; https://matcher.testnet-0bsnetwork.com","title":"Matcher API"},{"location":"python/","text":"","title":"Python Library"},{"location":"smartcontracts/","text":"Smart Contracts Smart Contracts pn our platform allow to change the default behaviour of accounts and assets. Smart contracts are: Scripts written using RIDE programming language. Predicates over account or asset transactions, which always should return true or false. Always passive and not callable. Smart Contract Script has access to: Blockchain height. There is height() function in the global scope of a script which returns the blockchain height at the execution time. Current transaction fields. There is tx variable in the global scope of a script which contains all fields of current outgoing transaction, including proofs array. Proofs array is not available in an asset script. Proofs. Any transaction can contain an array of proofs up to 8 elements. By default proofs array used for signatures, but you can put any data in the array (each element is up to 64 bytes). Key-value storage of any account. Data saved by a data transaction. Smart Accounts 0bsNetwork uses an account-based model, there are no inputs and outputs of transactions like in some other blockchain networks. All assets and data associates with an account and bound to its' public key. By default, public key \u201cowns\u201d assets and stores key-value data attached by data transactions. To spend funds or update key-value storage the sender provides a valid signature matching transaction body and public key. The main idea that before the transaction is submitted to be included in the next block, the account checks if the transaction meets certain requirements, defined in a script. The script is attached to the account so the account can validate every transaction before confirming it. Smart contract (account script) allows us to change the default behaviour of an account by sending a setScriptTransaction. It's important that the smart account does not store any data on the blockchain. A smart account will only have access to blockchain state values that can be retrieved and executed relatively fast, in a \u201cconstant\u201d time. Any normal account/address can become a smart account. How to work with state If you're familiar with Ethereum smart contracts model you have to consider the main difference between them and our Smart Contracts: 0bsnetwork smart contracts do not have their own state. There is a smart account state managed by data transactions. If you need to work with state you have to use data transactions and manage them with smart account scripts. Gas and fees The simplicity of account scripts makes the system very scalable in terms of throughput and smart accounts work without \u201cgas\u201d, which means that costs are always known upfront. Transactions from smart account or with smart asset require additional an additional fee documented in transactions Restrictions Smart accounts cannot send transactions themselves or transfer funds according to given conditions, but can read data from the blockchain (for example, the height of a blockchain or signatures from the transaction) and return the result of a predicate obtained on the basis of this data. Smart Assets If we plan to apply constraints on all operations for a specific asset, we cannot use a smart account. In our paradigm we have smart assets for this purpose: the script will be attached to the asset and will work in a similar way. Transactions for such assets are valid only if the script returns True. For example, a script can verify proofs from a transaction, check if a notary/escrow approves the transaction, and that operations with the asset are not locked for a specified time. The script for the token is invoked upon the following operations with an asset: Transfer Transaction MassTransfer Transaction Reissue Transaction Burn Transaction ExchangeTransaction SetAssetScriptTransaction Getting Started The best way to get started with RIDE and smart contracts is to dive right in and check out some examples, the lanuage is easy and readable, and our IDE already has samples pre-installed that you can load up. Smart Account Examples An account can trade only with BTC let cooperPubKey = base58'BVqYXrapgJP9atQccdBPAgJPwHDKkh6A8' let BTCId = base58'BTC Asset ID' match tx { case o: Order => sigVerify(tx.bodyBytes, tx.proofs[0], cooperPubKey ) && (o.assetPair.priceAsset == BTCId || o.assetPair.amountAsset == BTCId) case _ => sigVerify(tx.bodyBytes, tx.proofs[0], cooperPubKey ) } Buy back custom asset on specified price in ZBS let myAssetId = base58'BVqYXrapgJP9atQccdBPAgJPwHDKkh6B9' let cooperPubKey = base58'BVqYXrapgJP9atQccdBPAgJPwHDKkh6A8' match tx { case o: Order => o.assetPair.priceAsset == base58'' && o.assetPair.amountAsset == myAssetId && o.price == 500000 && o.amount == 1000 && o.orderType == Buy case _ => sigVerify(tx.bodyBytes, tx.proofs[0], cooperPubKey ) } Smart Asset Examples Issue an unburnable asset To issue an unburnable asset you can use pattern matching with a false value to BurnTransaction: match tx { case t : BurnTransaction => false case _ => true } Asset You can freeze your assets till the certain height by defining a target height variable: let targetHeight = 1500000 height >= targetHeight Getting a share after each asset transfer For requiring a fee in a certain asset to get a share after each transfer you can use TransferTransaction depending on the asset id: match tx { case t : TransferTransaction => t.feeAssetId == base58'oWgJN6YGZFtZrV8BWQ1PGktZikgg7jzGmtm16Ktyvjd' case _ => true } Transferring by issuer permission You can restrict the token transfer option to be done only by the token issuer's permission (commitment/debt label): match tx { case tx : TransferTransaction => let issuer = Address(base58'3P6ms9EotRX8JwSrebeTXYVnzpsGCrKWLv4') isDefined(getInteger(issuer, toBase58String(tx.id))) case _ => false } Issue an untransferable asset To make the asset untransferable, you can assign a false value to TransferTransaction, MassTransferTransaction and ExchangeTransaction: match tx { case t : TransferTransaction | MassTransferTransaction | ExchangeTransaction => false case _ => true } Asset tradable only with BTC To allow asset trading only with bitcoins you can do as here: let BTCId = base58'8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS' match tx { case t : ExchangeTransaction => t.sellOrder.assetPair.priceAsset == BTCId || t.sellOrder.assetPair.amountAsset == BTCId case _ => true } Require using a certain matcher To define a certain matcher, you can assign the matcher address as a sender value: match tx { case t : ExchangeTransaction => t.sender == addressFromString(\"3PJaDyprvekvPXPuAtxrapacuDJopgJRaU3\") case _ => true }","title":"Smart Contracts"},{"location":"smartcontracts/#smart-contracts","text":"Smart Contracts pn our platform allow to change the default behaviour of accounts and assets. Smart contracts are: Scripts written using RIDE programming language. Predicates over account or asset transactions, which always should return true or false. Always passive and not callable. Smart Contract Script has access to: Blockchain height. There is height() function in the global scope of a script which returns the blockchain height at the execution time. Current transaction fields. There is tx variable in the global scope of a script which contains all fields of current outgoing transaction, including proofs array. Proofs array is not available in an asset script. Proofs. Any transaction can contain an array of proofs up to 8 elements. By default proofs array used for signatures, but you can put any data in the array (each element is up to 64 bytes). Key-value storage of any account. Data saved by a data transaction.","title":"Smart Contracts"},{"location":"smartcontracts/#smart-accounts","text":"0bsNetwork uses an account-based model, there are no inputs and outputs of transactions like in some other blockchain networks. All assets and data associates with an account and bound to its' public key. By default, public key \u201cowns\u201d assets and stores key-value data attached by data transactions. To spend funds or update key-value storage the sender provides a valid signature matching transaction body and public key. The main idea that before the transaction is submitted to be included in the next block, the account checks if the transaction meets certain requirements, defined in a script. The script is attached to the account so the account can validate every transaction before confirming it. Smart contract (account script) allows us to change the default behaviour of an account by sending a setScriptTransaction. It's important that the smart account does not store any data on the blockchain. A smart account will only have access to blockchain state values that can be retrieved and executed relatively fast, in a \u201cconstant\u201d time. Any normal account/address can become a smart account.","title":"Smart Accounts"},{"location":"smartcontracts/#how-to-work-with-state","text":"If you're familiar with Ethereum smart contracts model you have to consider the main difference between them and our Smart Contracts: 0bsnetwork smart contracts do not have their own state. There is a smart account state managed by data transactions. If you need to work with state you have to use data transactions and manage them with smart account scripts.","title":"How to work with state"},{"location":"smartcontracts/#gas-and-fees","text":"The simplicity of account scripts makes the system very scalable in terms of throughput and smart accounts work without \u201cgas\u201d, which means that costs are always known upfront. Transactions from smart account or with smart asset require additional an additional fee documented in transactions","title":"Gas and fees"},{"location":"smartcontracts/#restrictions","text":"Smart accounts cannot send transactions themselves or transfer funds according to given conditions, but can read data from the blockchain (for example, the height of a blockchain or signatures from the transaction) and return the result of a predicate obtained on the basis of this data.","title":"Restrictions"},{"location":"smartcontracts/#smart-assets","text":"If we plan to apply constraints on all operations for a specific asset, we cannot use a smart account. In our paradigm we have smart assets for this purpose: the script will be attached to the asset and will work in a similar way. Transactions for such assets are valid only if the script returns True. For example, a script can verify proofs from a transaction, check if a notary/escrow approves the transaction, and that operations with the asset are not locked for a specified time. The script for the token is invoked upon the following operations with an asset: Transfer Transaction MassTransfer Transaction Reissue Transaction Burn Transaction ExchangeTransaction SetAssetScriptTransaction","title":"Smart Assets"},{"location":"smartcontracts/#getting-started","text":"The best way to get started with RIDE and smart contracts is to dive right in and check out some examples, the lanuage is easy and readable, and our IDE already has samples pre-installed that you can load up.","title":"Getting Started"},{"location":"smartcontracts/#smart-account-examples","text":"","title":"Smart Account Examples"},{"location":"smartcontracts/#an-account-can-trade-only-with-btc","text":"let cooperPubKey = base58'BVqYXrapgJP9atQccdBPAgJPwHDKkh6A8' let BTCId = base58'BTC Asset ID' match tx { case o: Order => sigVerify(tx.bodyBytes, tx.proofs[0], cooperPubKey ) && (o.assetPair.priceAsset == BTCId || o.assetPair.amountAsset == BTCId) case _ => sigVerify(tx.bodyBytes, tx.proofs[0], cooperPubKey ) }","title":"An account can trade only with BTC"},{"location":"smartcontracts/#buy-back-custom-asset-on-specified-price-in-zbs","text":"let myAssetId = base58'BVqYXrapgJP9atQccdBPAgJPwHDKkh6B9' let cooperPubKey = base58'BVqYXrapgJP9atQccdBPAgJPwHDKkh6A8' match tx { case o: Order => o.assetPair.priceAsset == base58'' && o.assetPair.amountAsset == myAssetId && o.price == 500000 && o.amount == 1000 && o.orderType == Buy case _ => sigVerify(tx.bodyBytes, tx.proofs[0], cooperPubKey ) }","title":"Buy back custom asset on specified price in ZBS"},{"location":"smartcontracts/#smart-asset-examples","text":"","title":"Smart Asset Examples"},{"location":"smartcontracts/#issue-an-unburnable-asset","text":"To issue an unburnable asset you can use pattern matching with a false value to BurnTransaction: match tx { case t : BurnTransaction => false case _ => true }","title":"Issue an unburnable asset"},{"location":"smartcontracts/#asset","text":"You can freeze your assets till the certain height by defining a target height variable: let targetHeight = 1500000 height >= targetHeight","title":"Asset"},{"location":"smartcontracts/#getting-a-share-after-each-asset-transfer","text":"For requiring a fee in a certain asset to get a share after each transfer you can use TransferTransaction depending on the asset id: match tx { case t : TransferTransaction => t.feeAssetId == base58'oWgJN6YGZFtZrV8BWQ1PGktZikgg7jzGmtm16Ktyvjd' case _ => true }","title":"Getting a share after each asset transfer"},{"location":"smartcontracts/#transferring-by-issuer-permission","text":"You can restrict the token transfer option to be done only by the token issuer's permission (commitment/debt label): match tx { case tx : TransferTransaction => let issuer = Address(base58'3P6ms9EotRX8JwSrebeTXYVnzpsGCrKWLv4') isDefined(getInteger(issuer, toBase58String(tx.id))) case _ => false }","title":"Transferring by issuer permission"},{"location":"smartcontracts/#issue-an-untransferable-asset","text":"To make the asset untransferable, you can assign a false value to TransferTransaction, MassTransferTransaction and ExchangeTransaction: match tx { case t : TransferTransaction | MassTransferTransaction | ExchangeTransaction => false case _ => true }","title":"Issue an untransferable asset"},{"location":"smartcontracts/#asset-tradable-only-with-btc","text":"To allow asset trading only with bitcoins you can do as here: let BTCId = base58'8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS' match tx { case t : ExchangeTransaction => t.sellOrder.assetPair.priceAsset == BTCId || t.sellOrder.assetPair.amountAsset == BTCId case _ => true }","title":"Asset tradable only with BTC"},{"location":"smartcontracts/#require-using-a-certain-matcher","text":"To define a certain matcher, you can assign the matcher address as a sender value: match tx { case t : ExchangeTransaction => t.sender == addressFromString(\"3PJaDyprvekvPXPuAtxrapacuDJopgJRaU3\") case _ => true }","title":"Require using a certain matcher"},{"location":"transactions/","text":"Transactions Transaction Types Each transaction type is given an integer to represent it as follows. The transaction fee is included below too, though libraries should have these set by default. Transaction Type Name Description Fee (ZBS) 3 Issue Create a new token / asset 500.00 4 Transfer Send ZBS or Token to another address 0.05 5 ReIssue Issue more of your token 200.00 6 Burn Destroy X tokens 5.00 7 Exchange A Trade. Buy / Sell 0.20 8 Lease Start leasing to another address 5.00 9 LeaseCancel Cancel a Lease 1.00 10 CreateAlias Create an alias for your address 10 11 MassTransfer Send up to 100 Transfers in 1 transaction 0.05 12 Data Save data to the blockchain 0.03 13 SetScript Add a script to an Address 10.00 14 CustomFee Setup a Custom Fee for your Asset 50.00 15 SetAsset Set a script on an asset 10.00 16 ContractInvoke Run a contract 0.10 Extra Fee: 0.01 (In addition to fee when operating with smart assets or accounts) Transaction Formats The below sections demonstrate the JSON transaction format that is required to make a transaction. When signing a transaction on a Node, you can exclude the signature/proofs field as the server will give you this back. Within the transaction JSON, Fee's are expressed without decimal values, so ZBS has 8 decimal places, and 100000000 represents 1 ZCL within the transaction JSON. Issue / ReIssue Transaction Issue and ReIssue take the same format apart from the type { \"senderPublicKey\":\"2M25DqL2W4rGFLCFadgATboS8EPqyWAN3DjH12AH5Kdr\", \"quantity\": 50000 \"fee\": 50000000000, \"description\":\"My New Token\", \"type\":3 / 5, \"version\":2, \"reissuable\":true, \"script\":\"base64:AQa3b8tH\", // Optional Script for 'Smart Assets' \"sender\":\"3Mz9N7YPfZPWGd4yYaX6H53Gcgrq6ifYiH7\", \"feeAssetId\":null, // When paying using custom fees \"chainId\":84, // 84 (T) for testnet 90 (Z) for mainnet \"proofs\":[\"4yjVxzrLuXUq5y2QCa2LDn1Fp9P63hPBmqDLGQCqn41EB1uZ1pys79NP81h7FxRBnZSbpNGbz1xjwckHcPAQHmFX\"], \"decimals\":2, \"name\":\"MyTestToken\" } Transfer Transaction { \"senderPublicKey\":\"4c5K4kGeRdrnSYZ9wngQKSozikVgfxmDEuViirsyUHwd\", \"amount\":110000000 fee\":500000, \"type\":4, \"version\":2, \"attachment\":\"\", \"sender\":\"3MyT3r1S8xvKtiKnLgVNNiSAiQdnMbffBQy\", \"feeAssetId\":null, \"proofs\":[\"2KFbYWi9BJwDG9dbiJQzC9qJPpu4Ug8Ybs331fQbX9FAkEpEtrj9DKvwNG7cb2m98DV6NCoKH4MBVtGGFsnQWPV6\"], \"assetId\":null, // If we are sending an asset, null for ZBS \"recipient\":\"3MqEisFsWdhvDMAKBwZzZv4niVsfJJtxcaw\", \"feeAsset\":null } Burn Transaction Burning tokens can be useful for systems where a token is used to activate or fund a service and once the service has been used the token can be burnt. { \"senderPublicKey\":\"HQWkhM5q6rtv8Z4MgKicfWdDyUABtr8md7ddgMDmZhuA\", \"amount\":1000000, \"fee\":500000000, \"type\":6, \"version\":2, \"sender\":\"3MpS4Bx7WtJtnFqxTTHWrMdiJBmpdWFbd35\", \"feeAssetId\":null, \"chainId\": 84, // 84 (T) for testnet 90 (Z) for mainnet \"proofs\":[\"5VXSiBmexMLYRpYrFeTbz5Psf4MRxhpiwXjasDGMJHTnmQcjtRx8HkubEu4zYBT2NUQYpPUmwmSbowgts6YhxdHS\"],\"assetId\":\"CS9Nc8aiK1FmvBHsj7JN4zE7u2dQnDJ2557dWcZxFHGy\" // The AssetId we wish to burn } Exchange Transaction { \"senderPublicKey\":\"8QUAqtTckM5B8gvcuP7mMswat9SjKUuafJMusEoSn1Gy\", \"amount\":1000000000, \"fee\":300000, \"type\":7, \"version\":2, \"sellMatcherFee\":30000, \"buyMatcherFee\":300000, \"sender\":\"3N8aZG6ZDfnh8YxS6aNcteobN8eXTWHaBBd\", \"feeAssetId\":null, \"proofs\":[\"4kBxzWXSzbM4jQbi8SmNtZeRJEwUkMzCezf8AQYeu5z124ajpKG9GVJZbHdnRWz9R1Key5opySDbKj6B4zTtZsNF\"], \"price\":90, \"id\":\"28biMwpgZVjAUk5iJnWvphaFgr8Tybwqe6s5JxGTdDWJ\", \"order2\": {\"version\":2, \"id\":\"GaCXusGNDkYZ8iciV3cuUKb7r4awESwocghJXnFyLxYk\", \"sender\":\"3MwBD8xZByEHAnwB69eexgVPAPD5ucw1Rna\",\"senderPublicKey\":\"HHonWv97CD2XXgRNbny7aCWP8amgYatCaTEthq38P1Do\",\"matcherPublicKey\":\"8QUAqtTckM5B8gvcuP7mMswat9SjKUuafJMusEoSn1Gy\", //Obtained from https://matcher.testnet-0bsnetwork.com/matcher \"assetPair\": { \"amountAsset\":\"4CFzLzP3vBHBev9GyeWm6AP7hm72qn6xELU1je5Wmq8L\", \"priceAsset\":null }, \"orderType\":\"sell\", \"amount\":10000000000, \"price\":90, \"timestamp\":1548657730301, \"expiration\":1551163330301, \"matcherFee\":300000,\"signature\":\"2uX8CedW8oPXqktAwJLm9emFArUimxcXD9pqHnd2mEWJYYJuBChzk59fzB7DVeKnczmosJa4vfAvCzqY8DSoq4Rr\",\"proofs\":[\"2uX8CedW8oPXqktAwJLm9emFArUimxcXD9pqHnd2mEWJYYJuBChzk59fzB7DVeKnczmosJa4vfAvCzqY8DSoq4Rr\"] }, \"order1\": { \"version\":2, \"id\":\"4EFqAQLW8S2Swo3dh5RZ5DXNtfQRDij7Y28RayN3vW7G\", \"sender\":\"3N5h5G6ToFR7cMMzdzR1hvUaMNuz7quCt4H\",\"senderPublicKey\":\"He5xRqcQBzk1VbdH7GP3XdGbB7dLwsvEbyLfNAbVkunJ\",\"matcherPublicKey\":\"8QUAqtTckM5B8gvcuP7mMswat9SjKUuafJMusEoSn1Gy\", //Obtained from https://matcher.testnet-0bsnetwork.com/matcher \"assetPair\": { \"amountAsset\":\"4CFzLzP3vBHBev9GyeWm6AP7hm72qn6xELU1je5Wmq8L\", \"priceAsset\":null }, \"orderType\":\"buy\", \"amount\":1000000000, \"price\":100, \"timestamp\":1548661139113, \"expiration\":1548661439111, \"matcherFee\":300000,\"signature\":\"23mzQgZgjsKBCTLRLS8ktbtP6EZx3gABT9AF63UF4nuhS1o7XJgEGby2umhijo4t8yKuw1CmZ3UVab4A6vtod3H8\",\"proofs\":[\"23mzQgZgjsKBCTLRLS8ktbtP6EZx3gABT9AF63UF4nuhS1o7XJgEGby2umhijo4t8yKuw1CmZ3UVab4A6vtod3H8\"] } } Lease Transaction { \"senderPublicKey\":\"FB5ErjREo817duEBBQUqUdkgoPctQJEYuG3mU7w3AYjc\", \"amount\":1, \"fee\":500000000, \"type\":8, \"version\":2, \"sender\":\"3Mps7CZqB9nUbEirYyCMMoA7VbqrxLvJFSB\", \"feeAssetId\":null, \"proofs\":[\"fkWj6RkV722jhv72BY6Eo5BZ6N4T8nTPcmQVmoBs14Cv53W2VfRE7C9rT1TN4CZfAW2Y2YhVFm24NGZh75eBHq4\"],\"recipient\":\"3NCKpqzSnHmXhZEmqYy4U6RUKUAJDTxWgWP\" } Lease Cancel { \"senderPublicKey\":\"FB5ErjREo817duEBBQUqUdkgoPctQJEYuG3mU7w3AYjc\", \"amount\":1 \"fee\":100000000, \"type\":8, \"version\":2, \"sender\":\"3Mps7CZqB9nUbEirYyCMMoA7VbqrxLvJFSB\", \"feeAssetId\":null, \"proofs\":[\"fkWj6RkV722jhv72BY6Eo5BZ6N4T8nTPcmQVmoBs14Cv53W2VfRE7C9rT1TN4CZfAW2Y2YhVFm24NGZh75eBHq4\"],\"recipient\":\"3NCKpqzSnHmXhZEmqYy4U6RUKUAJDTxWgWP\" } Create Alias { \"senderPublicKey\":\"BVv1ZuE3gKFa6krwWJQwEmrLYUESuUabNCXgYTmCoBt6\", \"sender\":\"3N8S4UtauvDAzpLiaRyDdHn9muexWHhBP4D\", \"feeAssetId\":null, \"proofs\":[\"22QJfRKX7kUQt4qjdnUqZAnhqukqhnofE27uvP8Q5xnBf8M6PCNtWVGq2ngm6m7Voe7duys59D1yU9jhKrmdXDCe\"], \"fee\":1000000000, \"alias\":\"91f452553298770f\", \"id\":\"AD7KmXwoVNc2fXsmaxsHsrnT1tfPF3HsWYtfjFijVsvM\", \"type\":10, \"version\":2 } Mass Transfer Data SetScript CustomFee Enable Set Asset Invoke Script Signing Transactions Signing transactions manually is quite complex, and usually its best to use a library to do so, however if you find you dont have a library available for your platform of choice, you may need to do it manually. The process involves concatenting the byte values of fields from the transaction to create a long byte array, and signing this using Curve25519 and your private key, and inserting this into the transaction payload. Rather than include excessive details here on how to do that, the below code sample in C Sharp should be readable enough to understand how the process works, and you can also examine the code of our other libraries as they are all open source. If you need specific details or guidance, please do contact us using the details on the Front Page using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Security.Cryptography; using System.Numerics; using DictionaryObject = System.Collections.Generic.Dictionary<string, object>; using org.whispersystems.curve25519.csharp; using System.Reflection; using org.whispersystems.curve25519; using System.IO; using Program; namespace ZbsSignAndBroadcastDataTransaction { class Program { /// <summary> /// This is a raw demonstration of a Data transaction. It's purpose is to save data to the blockchain (Variable TransactionData) - The signing procedure is demonstrated below. /// </summary> // 3MqSRBfLsTzXssscX8crUH88zJegvyrd5WK // Seed Phrase: despair olive coconut design rubber proud silver rotate glow gloom extra income effort about summer // Private Key: Bq6dvj1v48EAyS34Nu6bZS7tWtaxgQnChQrJvxr5x1pM // Public Key: 7cgFXWXTGXemR2yHq1MYx8o7jVKq6Y4Y5bTyaJ478aeG // Replenish Balance: https://explorer.testnet-0bsnetwork.com/faucet private static readonly Curve25519 Cipher = Curve25519.getInstance(Curve25519.BEST); static void Main(string[] args) { byte Version = 1; byte TxType = 12; byte[] SenderPrivateKey; byte[] SenderPublicKey; byte[] transactionBytes; DateTime Timestamp = DateTime.UtcNow; SenderPrivateKey = Base58.Decode(\"Bq6dvj1v48EAyS34Nu6bZS7tWtaxgQnChQrJvxr5x1pM\"); // These are obtained from the client. X25519 Keys SenderPublicKey = Base58.Decode(\"7cgFXWXTGXemR2yHq1MYx8o7jVKq6Y4Y5bTyaJ478aeG\"); var TransactionData = new DictionaryObject { { \"test num\", (long)1 }, { \"test true\", true }, { \"test bytes\", new byte[] { 1, 2, 3, 4, 5}}, { \"test string\", \"Hello!\"} }; // To create a signature, we create a byte array. using (var stream = new MemoryStream()) using (var writer = new BinaryWriter(stream)) { writer.Write(TxType); // First we add the Transaction Type (Its a number.. 12 is Data transaction) writer.Write(Version); // Transaction version is set to 1 writer.Write(SenderPublicKey); writer.WriteShort((short)TransactionData.Count); // Next we set the number of data items we are sending, in this case, theres 4 (TransactionData) foreach (var pair in TransactionData) // For each data item we need to add its Length, Key and its value { var key = Encoding.UTF8.GetBytes(pair.Key); writer.WriteShort((short)key.Length); writer.Write(key); writer.WriteObject(pair.Value); } writer.WriteLong(Timestamp.ToLong()); writer.WriteLong(3000000); //Arbitary fee transactionBytes = stream.ToArray(); } // Next we take the byte array and sign it to generate a Proof. var proof = Cipher.calculateSignature(SenderPrivateKey, transactionBytes); // And finally, create a JSON payload to broadcast the transaction to the network var finalTransaction = new DictionaryObject { {\"type\", (byte) 12}, {\"version\", Version}, {\"senderPublicKey\", SenderPublicKey.ToBase58() }, {\"sender\", \"3MqSRBfLsTzXssscX8crUH88zJegvyrd5WK\" }, {\"data\", TransactionData.Select(pair => new DictionaryObject // Add each data entry to the JSON payload { {\"key\", pair.Key}, {\"type\", pair.Value is long ? \"integer\" : (pair.Value is bool ? \"boolean\" : (pair.Value is string ? \"string\" : \"binary\"))}, {\"value\", pair.Value is byte[] bytes ? bytes.ToBase64() : pair.Value } })}, {\"fee\", 3000000}, //Arbitary fee {\"timestamp\", Timestamp.ToLong()}, {\"proofs\", new string[] { proof.ToBase58()} } // Add the signature to the JSON }; String TestNetHost = \"https://node1.testnet-0bsnetwork.com\"; var response = Http.Post(TestNetHost + \"/transactions/broadcast\", finalTransaction); // Broadcast the transaction to a public node on the network Console.Write(response); // Output the response Console.Read(); } } }","title":"Transactions"},{"location":"transactions/#transactions","text":"","title":"Transactions"},{"location":"transactions/#transaction-types","text":"Each transaction type is given an integer to represent it as follows. The transaction fee is included below too, though libraries should have these set by default. Transaction Type Name Description Fee (ZBS) 3 Issue Create a new token / asset 500.00 4 Transfer Send ZBS or Token to another address 0.05 5 ReIssue Issue more of your token 200.00 6 Burn Destroy X tokens 5.00 7 Exchange A Trade. Buy / Sell 0.20 8 Lease Start leasing to another address 5.00 9 LeaseCancel Cancel a Lease 1.00 10 CreateAlias Create an alias for your address 10 11 MassTransfer Send up to 100 Transfers in 1 transaction 0.05 12 Data Save data to the blockchain 0.03 13 SetScript Add a script to an Address 10.00 14 CustomFee Setup a Custom Fee for your Asset 50.00 15 SetAsset Set a script on an asset 10.00 16 ContractInvoke Run a contract 0.10 Extra Fee: 0.01 (In addition to fee when operating with smart assets or accounts)","title":"Transaction Types"},{"location":"transactions/#transaction-formats","text":"The below sections demonstrate the JSON transaction format that is required to make a transaction. When signing a transaction on a Node, you can exclude the signature/proofs field as the server will give you this back. Within the transaction JSON, Fee's are expressed without decimal values, so ZBS has 8 decimal places, and 100000000 represents 1 ZCL within the transaction JSON.","title":"Transaction Formats"},{"location":"transactions/#issue-reissue-transaction","text":"Issue and ReIssue take the same format apart from the type { \"senderPublicKey\":\"2M25DqL2W4rGFLCFadgATboS8EPqyWAN3DjH12AH5Kdr\", \"quantity\": 50000 \"fee\": 50000000000, \"description\":\"My New Token\", \"type\":3 / 5, \"version\":2, \"reissuable\":true, \"script\":\"base64:AQa3b8tH\", // Optional Script for 'Smart Assets' \"sender\":\"3Mz9N7YPfZPWGd4yYaX6H53Gcgrq6ifYiH7\", \"feeAssetId\":null, // When paying using custom fees \"chainId\":84, // 84 (T) for testnet 90 (Z) for mainnet \"proofs\":[\"4yjVxzrLuXUq5y2QCa2LDn1Fp9P63hPBmqDLGQCqn41EB1uZ1pys79NP81h7FxRBnZSbpNGbz1xjwckHcPAQHmFX\"], \"decimals\":2, \"name\":\"MyTestToken\" }","title":"Issue / ReIssue Transaction"},{"location":"transactions/#transfer-transaction","text":"{ \"senderPublicKey\":\"4c5K4kGeRdrnSYZ9wngQKSozikVgfxmDEuViirsyUHwd\", \"amount\":110000000 fee\":500000, \"type\":4, \"version\":2, \"attachment\":\"\", \"sender\":\"3MyT3r1S8xvKtiKnLgVNNiSAiQdnMbffBQy\", \"feeAssetId\":null, \"proofs\":[\"2KFbYWi9BJwDG9dbiJQzC9qJPpu4Ug8Ybs331fQbX9FAkEpEtrj9DKvwNG7cb2m98DV6NCoKH4MBVtGGFsnQWPV6\"], \"assetId\":null, // If we are sending an asset, null for ZBS \"recipient\":\"3MqEisFsWdhvDMAKBwZzZv4niVsfJJtxcaw\", \"feeAsset\":null }","title":"Transfer Transaction"},{"location":"transactions/#burn-transaction","text":"Burning tokens can be useful for systems where a token is used to activate or fund a service and once the service has been used the token can be burnt. { \"senderPublicKey\":\"HQWkhM5q6rtv8Z4MgKicfWdDyUABtr8md7ddgMDmZhuA\", \"amount\":1000000, \"fee\":500000000, \"type\":6, \"version\":2, \"sender\":\"3MpS4Bx7WtJtnFqxTTHWrMdiJBmpdWFbd35\", \"feeAssetId\":null, \"chainId\": 84, // 84 (T) for testnet 90 (Z) for mainnet \"proofs\":[\"5VXSiBmexMLYRpYrFeTbz5Psf4MRxhpiwXjasDGMJHTnmQcjtRx8HkubEu4zYBT2NUQYpPUmwmSbowgts6YhxdHS\"],\"assetId\":\"CS9Nc8aiK1FmvBHsj7JN4zE7u2dQnDJ2557dWcZxFHGy\" // The AssetId we wish to burn }","title":"Burn Transaction"},{"location":"transactions/#exchange-transaction","text":"{ \"senderPublicKey\":\"8QUAqtTckM5B8gvcuP7mMswat9SjKUuafJMusEoSn1Gy\", \"amount\":1000000000, \"fee\":300000, \"type\":7, \"version\":2, \"sellMatcherFee\":30000, \"buyMatcherFee\":300000, \"sender\":\"3N8aZG6ZDfnh8YxS6aNcteobN8eXTWHaBBd\", \"feeAssetId\":null, \"proofs\":[\"4kBxzWXSzbM4jQbi8SmNtZeRJEwUkMzCezf8AQYeu5z124ajpKG9GVJZbHdnRWz9R1Key5opySDbKj6B4zTtZsNF\"], \"price\":90, \"id\":\"28biMwpgZVjAUk5iJnWvphaFgr8Tybwqe6s5JxGTdDWJ\", \"order2\": {\"version\":2, \"id\":\"GaCXusGNDkYZ8iciV3cuUKb7r4awESwocghJXnFyLxYk\", \"sender\":\"3MwBD8xZByEHAnwB69eexgVPAPD5ucw1Rna\",\"senderPublicKey\":\"HHonWv97CD2XXgRNbny7aCWP8amgYatCaTEthq38P1Do\",\"matcherPublicKey\":\"8QUAqtTckM5B8gvcuP7mMswat9SjKUuafJMusEoSn1Gy\", //Obtained from https://matcher.testnet-0bsnetwork.com/matcher \"assetPair\": { \"amountAsset\":\"4CFzLzP3vBHBev9GyeWm6AP7hm72qn6xELU1je5Wmq8L\", \"priceAsset\":null }, \"orderType\":\"sell\", \"amount\":10000000000, \"price\":90, \"timestamp\":1548657730301, \"expiration\":1551163330301, \"matcherFee\":300000,\"signature\":\"2uX8CedW8oPXqktAwJLm9emFArUimxcXD9pqHnd2mEWJYYJuBChzk59fzB7DVeKnczmosJa4vfAvCzqY8DSoq4Rr\",\"proofs\":[\"2uX8CedW8oPXqktAwJLm9emFArUimxcXD9pqHnd2mEWJYYJuBChzk59fzB7DVeKnczmosJa4vfAvCzqY8DSoq4Rr\"] }, \"order1\": { \"version\":2, \"id\":\"4EFqAQLW8S2Swo3dh5RZ5DXNtfQRDij7Y28RayN3vW7G\", \"sender\":\"3N5h5G6ToFR7cMMzdzR1hvUaMNuz7quCt4H\",\"senderPublicKey\":\"He5xRqcQBzk1VbdH7GP3XdGbB7dLwsvEbyLfNAbVkunJ\",\"matcherPublicKey\":\"8QUAqtTckM5B8gvcuP7mMswat9SjKUuafJMusEoSn1Gy\", //Obtained from https://matcher.testnet-0bsnetwork.com/matcher \"assetPair\": { \"amountAsset\":\"4CFzLzP3vBHBev9GyeWm6AP7hm72qn6xELU1je5Wmq8L\", \"priceAsset\":null }, \"orderType\":\"buy\", \"amount\":1000000000, \"price\":100, \"timestamp\":1548661139113, \"expiration\":1548661439111, \"matcherFee\":300000,\"signature\":\"23mzQgZgjsKBCTLRLS8ktbtP6EZx3gABT9AF63UF4nuhS1o7XJgEGby2umhijo4t8yKuw1CmZ3UVab4A6vtod3H8\",\"proofs\":[\"23mzQgZgjsKBCTLRLS8ktbtP6EZx3gABT9AF63UF4nuhS1o7XJgEGby2umhijo4t8yKuw1CmZ3UVab4A6vtod3H8\"] } }","title":"Exchange Transaction"},{"location":"transactions/#lease-transaction","text":"{ \"senderPublicKey\":\"FB5ErjREo817duEBBQUqUdkgoPctQJEYuG3mU7w3AYjc\", \"amount\":1, \"fee\":500000000, \"type\":8, \"version\":2, \"sender\":\"3Mps7CZqB9nUbEirYyCMMoA7VbqrxLvJFSB\", \"feeAssetId\":null, \"proofs\":[\"fkWj6RkV722jhv72BY6Eo5BZ6N4T8nTPcmQVmoBs14Cv53W2VfRE7C9rT1TN4CZfAW2Y2YhVFm24NGZh75eBHq4\"],\"recipient\":\"3NCKpqzSnHmXhZEmqYy4U6RUKUAJDTxWgWP\" }","title":"Lease Transaction"},{"location":"transactions/#lease-cancel","text":"{ \"senderPublicKey\":\"FB5ErjREo817duEBBQUqUdkgoPctQJEYuG3mU7w3AYjc\", \"amount\":1 \"fee\":100000000, \"type\":8, \"version\":2, \"sender\":\"3Mps7CZqB9nUbEirYyCMMoA7VbqrxLvJFSB\", \"feeAssetId\":null, \"proofs\":[\"fkWj6RkV722jhv72BY6Eo5BZ6N4T8nTPcmQVmoBs14Cv53W2VfRE7C9rT1TN4CZfAW2Y2YhVFm24NGZh75eBHq4\"],\"recipient\":\"3NCKpqzSnHmXhZEmqYy4U6RUKUAJDTxWgWP\" }","title":"Lease Cancel"},{"location":"transactions/#create-alias","text":"{ \"senderPublicKey\":\"BVv1ZuE3gKFa6krwWJQwEmrLYUESuUabNCXgYTmCoBt6\", \"sender\":\"3N8S4UtauvDAzpLiaRyDdHn9muexWHhBP4D\", \"feeAssetId\":null, \"proofs\":[\"22QJfRKX7kUQt4qjdnUqZAnhqukqhnofE27uvP8Q5xnBf8M6PCNtWVGq2ngm6m7Voe7duys59D1yU9jhKrmdXDCe\"], \"fee\":1000000000, \"alias\":\"91f452553298770f\", \"id\":\"AD7KmXwoVNc2fXsmaxsHsrnT1tfPF3HsWYtfjFijVsvM\", \"type\":10, \"version\":2 }","title":"Create Alias"},{"location":"transactions/#mass-transfer","text":"","title":"Mass Transfer"},{"location":"transactions/#data","text":"","title":"Data"},{"location":"transactions/#setscript","text":"","title":"SetScript"},{"location":"transactions/#customfee-enable","text":"","title":"CustomFee Enable"},{"location":"transactions/#set-asset","text":"","title":"Set Asset"},{"location":"transactions/#invoke-script","text":"","title":"Invoke Script"},{"location":"transactions/#signing-transactions","text":"Signing transactions manually is quite complex, and usually its best to use a library to do so, however if you find you dont have a library available for your platform of choice, you may need to do it manually. The process involves concatenting the byte values of fields from the transaction to create a long byte array, and signing this using Curve25519 and your private key, and inserting this into the transaction payload. Rather than include excessive details here on how to do that, the below code sample in C Sharp should be readable enough to understand how the process works, and you can also examine the code of our other libraries as they are all open source. If you need specific details or guidance, please do contact us using the details on the Front Page using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Security.Cryptography; using System.Numerics; using DictionaryObject = System.Collections.Generic.Dictionary<string, object>; using org.whispersystems.curve25519.csharp; using System.Reflection; using org.whispersystems.curve25519; using System.IO; using Program; namespace ZbsSignAndBroadcastDataTransaction { class Program { /// <summary> /// This is a raw demonstration of a Data transaction. It's purpose is to save data to the blockchain (Variable TransactionData) - The signing procedure is demonstrated below. /// </summary> // 3MqSRBfLsTzXssscX8crUH88zJegvyrd5WK // Seed Phrase: despair olive coconut design rubber proud silver rotate glow gloom extra income effort about summer // Private Key: Bq6dvj1v48EAyS34Nu6bZS7tWtaxgQnChQrJvxr5x1pM // Public Key: 7cgFXWXTGXemR2yHq1MYx8o7jVKq6Y4Y5bTyaJ478aeG // Replenish Balance: https://explorer.testnet-0bsnetwork.com/faucet private static readonly Curve25519 Cipher = Curve25519.getInstance(Curve25519.BEST); static void Main(string[] args) { byte Version = 1; byte TxType = 12; byte[] SenderPrivateKey; byte[] SenderPublicKey; byte[] transactionBytes; DateTime Timestamp = DateTime.UtcNow; SenderPrivateKey = Base58.Decode(\"Bq6dvj1v48EAyS34Nu6bZS7tWtaxgQnChQrJvxr5x1pM\"); // These are obtained from the client. X25519 Keys SenderPublicKey = Base58.Decode(\"7cgFXWXTGXemR2yHq1MYx8o7jVKq6Y4Y5bTyaJ478aeG\"); var TransactionData = new DictionaryObject { { \"test num\", (long)1 }, { \"test true\", true }, { \"test bytes\", new byte[] { 1, 2, 3, 4, 5}}, { \"test string\", \"Hello!\"} }; // To create a signature, we create a byte array. using (var stream = new MemoryStream()) using (var writer = new BinaryWriter(stream)) { writer.Write(TxType); // First we add the Transaction Type (Its a number.. 12 is Data transaction) writer.Write(Version); // Transaction version is set to 1 writer.Write(SenderPublicKey); writer.WriteShort((short)TransactionData.Count); // Next we set the number of data items we are sending, in this case, theres 4 (TransactionData) foreach (var pair in TransactionData) // For each data item we need to add its Length, Key and its value { var key = Encoding.UTF8.GetBytes(pair.Key); writer.WriteShort((short)key.Length); writer.Write(key); writer.WriteObject(pair.Value); } writer.WriteLong(Timestamp.ToLong()); writer.WriteLong(3000000); //Arbitary fee transactionBytes = stream.ToArray(); } // Next we take the byte array and sign it to generate a Proof. var proof = Cipher.calculateSignature(SenderPrivateKey, transactionBytes); // And finally, create a JSON payload to broadcast the transaction to the network var finalTransaction = new DictionaryObject { {\"type\", (byte) 12}, {\"version\", Version}, {\"senderPublicKey\", SenderPublicKey.ToBase58() }, {\"sender\", \"3MqSRBfLsTzXssscX8crUH88zJegvyrd5WK\" }, {\"data\", TransactionData.Select(pair => new DictionaryObject // Add each data entry to the JSON payload { {\"key\", pair.Key}, {\"type\", pair.Value is long ? \"integer\" : (pair.Value is bool ? \"boolean\" : (pair.Value is string ? \"string\" : \"binary\"))}, {\"value\", pair.Value is byte[] bytes ? bytes.ToBase64() : pair.Value } })}, {\"fee\", 3000000}, //Arbitary fee {\"timestamp\", Timestamp.ToLong()}, {\"proofs\", new string[] { proof.ToBase58()} } // Add the signature to the JSON }; String TestNetHost = \"https://node1.testnet-0bsnetwork.com\"; var response = Http.Post(TestNetHost + \"/transactions/broadcast\", finalTransaction); // Broadcast the transaction to a public node on the network Console.Write(response); // Output the response Console.Read(); } } }","title":"Signing Transactions"},{"location":"tutorials/","text":"Tutorials Smart Contract","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"","title":"Tutorials"},{"location":"tutorials/#smart-contract","text":"","title":"Smart Contract"}]}