{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the 0bsNetwork Developer Hub TIMBER HACKATHON NOTES: Java Demo for Android - Android also docs updated. This shows creating a transaction, signing it and getting the JSON. Then you need to POST it to a node using whatever your favourite HTTP Client is! React Sample - Demo App (Using signer service in EXPO App) Smart Contract Sample - See the smart contract page Signer API (Used for POC saving to blockchain, remote signing) Contact @JustJamesDev on Telegram or @zbsDev Group You'll find comprehensive guides and documentation to help you start working with the 0bsnetwork as quickly as possible, as well as support if you get stuck. Let's jump right in! This developer site is written with the \"Dev Without Blockchain Experience\" in mind who just wants to get started without learning blockchain inside out, lots of information is ommitted where it wont benefit the initial development flow, and instructions or examples are straight to the point. You shouldn't need to do much blockchain research before diving in, and our tools are standard tools that you will already be familiar with. We support enough languages and platforms for most developers to be able to get stuck in straight away and learn the blockchain parts as you go. You dont always need to know the minute cryptographic details of every operation so we have mostly left this information out, however it is available should you need it! Experienced blockchain developers can jump right to the relevant section, the below links may help. For non-developers / non-technial, or if you want more info about the network, governance, staking or features, please visit our website or docs site here; https://docs.0bsnetwork.com/ Quick Links Components and Services - Key Players Data Service Docs JavaScript Development React Library Get Started Quick Start Create your wallet at https://client.testnet-0bsnetwork.com Get some developer coins from : https://explorer.0bsnetwork.com/testnet/faucet Contact Info Telegram Group: https://t.me/zbsDev - Ask your development questions here Dev Support: dev@0bsnetwork.com Please let us know if you find any errors or confusing parts of the documentation, and we will get it updated or clarified right away!","title":"Home"},{"location":"#welcome-to-the-0bsnetwork-developer-hub","text":"","title":"Welcome to the 0bsNetwork Developer Hub"},{"location":"#timber-hackathon-notes","text":"Java Demo for Android - Android also docs updated. This shows creating a transaction, signing it and getting the JSON. Then you need to POST it to a node using whatever your favourite HTTP Client is! React Sample - Demo App (Using signer service in EXPO App) Smart Contract Sample - See the smart contract page Signer API (Used for POC saving to blockchain, remote signing) Contact @JustJamesDev on Telegram or @zbsDev Group You'll find comprehensive guides and documentation to help you start working with the 0bsnetwork as quickly as possible, as well as support if you get stuck. Let's jump right in! This developer site is written with the \"Dev Without Blockchain Experience\" in mind who just wants to get started without learning blockchain inside out, lots of information is ommitted where it wont benefit the initial development flow, and instructions or examples are straight to the point. You shouldn't need to do much blockchain research before diving in, and our tools are standard tools that you will already be familiar with. We support enough languages and platforms for most developers to be able to get stuck in straight away and learn the blockchain parts as you go. You dont always need to know the minute cryptographic details of every operation so we have mostly left this information out, however it is available should you need it! Experienced blockchain developers can jump right to the relevant section, the below links may help. For non-developers / non-technial, or if you want more info about the network, governance, staking or features, please visit our website or docs site here; https://docs.0bsnetwork.com/","title":"TIMBER HACKATHON NOTES:"},{"location":"#quick-links","text":"Components and Services - Key Players Data Service Docs JavaScript Development React Library","title":"Quick Links"},{"location":"#get-started-quick-start","text":"Create your wallet at https://client.testnet-0bsnetwork.com Get some developer coins from : https://explorer.0bsnetwork.com/testnet/faucet","title":"Get Started Quick Start"},{"location":"#contact-info","text":"Telegram Group: https://t.me/zbsDev - Ask your development questions here Dev Support: dev@0bsnetwork.com Please let us know if you find any errors or confusing parts of the documentation, and we will get it updated or clarified right away!","title":"Contact Info"},{"location":"about/","text":"About 0bsNetwork 0bsNetwork is a LPOS - Leasing Proof of Stake BlockChain, this differs from something like Bitcoin or Ethereum, as rather than having miners producing proof of work, for example, generating hashes to solve a challenge, a stake of coins instead secures the network. In our case, the coin is ZBS coin. Running a full node on the network requires that the node has a 'generating balance' of at least 1000 ZBS coins, these can either be in the nodes wallet, or leased to the node. Once your node has established 1000 ZBS generating balance it will begin generating blocks. The more coins you have, the more often you will generate a block. Nodes that generate blocks recieve the transaction fees as the reward (As opposed to the block reward in bitcoin) Our network is entirely pre-mined, in a good way, we have 51m coins issued in the genesis block, so the supply will never change. You can create a token on our platform right from the wallet (Or using a library or API if you wish) and set its supply, details etc. These are also refferred to 'assets' within the code and transactions. We have 2 networks, one for developing on called testnet, and one 'live' network called mainnet. All the documentation refers to testnet and your app can be changed to mainnet later. Our block time is 1 minute, and as soon as a transaction is broadcast to the network its added to a block by the current mining node. Once the block has been finalised and propogated to the network, this is considered as a confirmation. However, acceptance into a block means that the transaction is valid and WILL be included in the block. Without further ado, lets move onto getting started where we explain all the parts of the system, and what you need to get up and running","title":"About 0bsNetwork"},{"location":"about/#about-0bsnetwork","text":"0bsNetwork is a LPOS - Leasing Proof of Stake BlockChain, this differs from something like Bitcoin or Ethereum, as rather than having miners producing proof of work, for example, generating hashes to solve a challenge, a stake of coins instead secures the network. In our case, the coin is ZBS coin. Running a full node on the network requires that the node has a 'generating balance' of at least 1000 ZBS coins, these can either be in the nodes wallet, or leased to the node. Once your node has established 1000 ZBS generating balance it will begin generating blocks. The more coins you have, the more often you will generate a block. Nodes that generate blocks recieve the transaction fees as the reward (As opposed to the block reward in bitcoin) Our network is entirely pre-mined, in a good way, we have 51m coins issued in the genesis block, so the supply will never change. You can create a token on our platform right from the wallet (Or using a library or API if you wish) and set its supply, details etc. These are also refferred to 'assets' within the code and transactions. We have 2 networks, one for developing on called testnet, and one 'live' network called mainnet. All the documentation refers to testnet and your app can be changed to mainnet later. Our block time is 1 minute, and as soon as a transaction is broadcast to the network its added to a block by the current mining node. Once the block has been finalised and propogated to the network, this is considered as a confirmation. However, acceptance into a block means that the transaction is valid and WILL be included in the block. Without further ado, lets move onto getting started where we explain all the parts of the system, and what you need to get up and running","title":"About 0bsNetwork"},{"location":"componentsandservices/","text":"Introduction This section will explain all the parts of our platform from a developers point of view. To check the status of any of our central services you can visit https://status.0bsnetwork.com/ And you can also run any of these services yourself. Key Players Full Node This is the 'core' of our platform. Each node processes transactions into blocks. A node contains a wallet. A collection of nodes create ... The Network We have 2 networks, MainNet and TestNet. Testnet is where all development can take place as the coins are worthless, and you can afford to make mistakes. You can think of MainNet as 'Production'. For MainNet you can replace testnet- in all the URLs in this documentation. Full Node API Our full node exposes an API for; - Transactions (Creating and Broadcasting) - Node, Network and Address information - Node operation and configuration However, in some cases, to get aggregate data such as data from data transactions, you are better using the data service API listed below. Client / Wallet A hosted version of a wallet for those that do not run a full node, it connects to our full node to get its information by default but you can also point it at your own node. Here you can view your balances, create tokens, Send and receive, Trade and view blockchain info https://client.testnet-0bsnetwork.com Faucet A 'Faucet' allows you to obtain free testnet coins in order to build your project. You can go to https://explorer.0bsnetwork.com/testnet/faucet and simply enter your address to obtain 250 free testnet coins Block Explorer Our block explorer lists all the blocks within our network, you can drill down to transaction level and see all the details. This is useful to look into transactions as you are developing to check you get the expected result. https://explorer.0bsnetwork.com (Select testnet from dropdown) IDE / Smart Contracts Our smart contracts are written in a language called RIDE and can be applied to either an Asset to create a 'Smart Asset' or an account (Address) to create a 'Smart Account' This enables us to create behaviours on a token (Trading restraints for example) or an account (Multi Signature) You can have a play and use our REPL at the below link. There's also some sample scripts and you can deploy right from the IDE page. https://ide.0bsnetwork.com Data Service This is a nice fast rest API that exposes information from our blockchain such as; Data from data transactions (Ability to query and filter) Information about Assets Trading Information (Stats, Prices, Volume) See the Data Service API Section for details Matcher The matcher is our trading 'engine' taking orders for sells and buys and matching them up, the matcher hosts the orderbook and also has an API https://matcher.testnet-0bsnetwork.com Libraries We have a library for many differnet languages and platforms and more are being added every day. The libraries are firstly an interface to the Node and Matcher API, with the addition of the ability to sign transactions and broadcast them to the node (Signing transactions manually is a little tricky) Most of our libraries are community supported, so if you find an issue or error, log an issue in the repository.. Or feel free to raise a pull request! 0bsLink 0bsLink is a browser add-on / extension that is essentially a wallet, however it comes with an API so you can build a wabpage to interact with this extension, to build 0bsNetwork powered web applicaitons witout having to deal with any of the complexity. IDE & REPL This is where you can code and test smart contracts, as well as use our REPL.. This tool comes with plenty of examples and help, so dive right in and check it out. Always worth having this open in a tab during development! https://ide.testnet-0bsnetwork.com","title":"Components and Services"},{"location":"componentsandservices/#introduction","text":"This section will explain all the parts of our platform from a developers point of view. To check the status of any of our central services you can visit https://status.0bsnetwork.com/ And you can also run any of these services yourself.","title":"Introduction"},{"location":"componentsandservices/#key-players","text":"","title":"Key Players"},{"location":"componentsandservices/#full-node","text":"This is the 'core' of our platform. Each node processes transactions into blocks. A node contains a wallet. A collection of nodes create ...","title":"Full Node"},{"location":"componentsandservices/#the-network","text":"We have 2 networks, MainNet and TestNet. Testnet is where all development can take place as the coins are worthless, and you can afford to make mistakes. You can think of MainNet as 'Production'. For MainNet you can replace testnet- in all the URLs in this documentation.","title":"The Network"},{"location":"componentsandservices/#full-node-api","text":"Our full node exposes an API for; - Transactions (Creating and Broadcasting) - Node, Network and Address information - Node operation and configuration However, in some cases, to get aggregate data such as data from data transactions, you are better using the data service API listed below.","title":"Full Node API"},{"location":"componentsandservices/#client-wallet","text":"A hosted version of a wallet for those that do not run a full node, it connects to our full node to get its information by default but you can also point it at your own node. Here you can view your balances, create tokens, Send and receive, Trade and view blockchain info https://client.testnet-0bsnetwork.com","title":"Client / Wallet"},{"location":"componentsandservices/#faucet","text":"A 'Faucet' allows you to obtain free testnet coins in order to build your project. You can go to https://explorer.0bsnetwork.com/testnet/faucet and simply enter your address to obtain 250 free testnet coins","title":"Faucet"},{"location":"componentsandservices/#block-explorer","text":"Our block explorer lists all the blocks within our network, you can drill down to transaction level and see all the details. This is useful to look into transactions as you are developing to check you get the expected result. https://explorer.0bsnetwork.com (Select testnet from dropdown)","title":"Block Explorer"},{"location":"componentsandservices/#ide-smart-contracts","text":"Our smart contracts are written in a language called RIDE and can be applied to either an Asset to create a 'Smart Asset' or an account (Address) to create a 'Smart Account' This enables us to create behaviours on a token (Trading restraints for example) or an account (Multi Signature) You can have a play and use our REPL at the below link. There's also some sample scripts and you can deploy right from the IDE page. https://ide.0bsnetwork.com","title":"IDE / Smart Contracts"},{"location":"componentsandservices/#data-service","text":"This is a nice fast rest API that exposes information from our blockchain such as; Data from data transactions (Ability to query and filter) Information about Assets Trading Information (Stats, Prices, Volume) See the Data Service API Section for details","title":"Data Service"},{"location":"componentsandservices/#matcher","text":"The matcher is our trading 'engine' taking orders for sells and buys and matching them up, the matcher hosts the orderbook and also has an API https://matcher.testnet-0bsnetwork.com","title":"Matcher"},{"location":"componentsandservices/#libraries","text":"We have a library for many differnet languages and platforms and more are being added every day. The libraries are firstly an interface to the Node and Matcher API, with the addition of the ability to sign transactions and broadcast them to the node (Signing transactions manually is a little tricky) Most of our libraries are community supported, so if you find an issue or error, log an issue in the repository.. Or feel free to raise a pull request!","title":"Libraries"},{"location":"componentsandservices/#0bslink","text":"0bsLink is a browser add-on / extension that is essentially a wallet, however it comes with an API so you can build a wabpage to interact with this extension, to build 0bsNetwork powered web applicaitons witout having to deal with any of the complexity.","title":"0bsLink"},{"location":"componentsandservices/#ide-repl","text":"This is where you can code and test smart contracts, as well as use our REPL.. This tool comes with plenty of examples and help, so dive right in and check it out. Always worth having this open in a tab during development! https://ide.testnet-0bsnetwork.com","title":"IDE &amp; REPL"},{"location":"cs/","text":"ZbsCS A C# library for interacting with the 0bsNetwork blockchain Supports node interaction, offline transaction signing, Matcher orders, and creating addresses and keys. Getting Started Include the project in your project, and Add a Reference using ZbsCS; For installation via UI Package Manager use this instruction . Target framework .NET Framework 4.5.1 Documentation The library utilizes classes to represent various Zbs data structures and encoding and serialization methods: ZbsCS.Node ZbsCS.Order ZbsCS.OrderBook ZbsCS.PrivateKeyAccount ZbsCS.Transaction ZbsCS.AddressEncoding ZbsCS.Base58 ZbsCS.Utils Code Example Code examples are in ZbsCSTests project and Examples page. Source code [ZbsCS Github repository](https://github.com/0bsnetwork/ZbsCS","title":"C# Library"},{"location":"cs/#zbscs","text":"A C# library for interacting with the 0bsNetwork blockchain Supports node interaction, offline transaction signing, Matcher orders, and creating addresses and keys.","title":"ZbsCS"},{"location":"cs/#getting-started","text":"Include the project in your project, and Add a Reference using ZbsCS; For installation via UI Package Manager use this instruction . Target framework .NET Framework 4.5.1","title":"Getting Started"},{"location":"cs/#documentation","text":"The library utilizes classes to represent various Zbs data structures and encoding and serialization methods: ZbsCS.Node ZbsCS.Order ZbsCS.OrderBook ZbsCS.PrivateKeyAccount ZbsCS.Transaction ZbsCS.AddressEncoding ZbsCS.Base58 ZbsCS.Utils","title":"Documentation"},{"location":"cs/#code-example","text":"Code examples are in ZbsCSTests project and Examples page.","title":"Code Example"},{"location":"cs/#source-code","text":"[ZbsCS Github repository](https://github.com/0bsnetwork/ZbsCS","title":"Source code"},{"location":"dataservice/","text":"Data Service API Our data service API stores information about the blockchain, data, and trading. We host a public version of the API, and if you need more limits (Public API limits number of results in 1 page) you can also run your own dockerised version of this API. You can use this API to, for example, get a list of all data submitted on an account within 24 hours. It's much quicker and easier than using the Node API where you would have to pull a list of all blocks and transactions and locate the right data. The documentation for the API is located at; https://api.testnet-0bsnetwork.com/docs Below is a demonstration of using the API Demo Here's a quick demo of our data API. This is a small docker container that runs alongside a node (NodeJS + PostGreSQL) and either you could run your own if your data querying requirements are large, or use our public one for smaller queries (There's smaller limits in place on the public one) So, Lets say we want to get all data transactions for a particular ID, in this case, I've been saving data from my orange tree, which has a 'plantId' of '23456-f344f3' So the filters we have available on the data transaction endpoint are as follows sender - public address of the data transaction sender timeStart - Start Time (e.g. 2019-05-29T03:51:05.303Z) or just date timeEnd - End Time (As Above) key - Filter by Key type - Filter by data type value - Filer by value after - Insert the previous pages cursor (lastCursor) to get the next set of records (depending on limit) limit - How many to return (Default 100 Max 1000) So, if we want to get all data transactions on the 27th May for my plant, we can query like this (Lets say we want them in pages of 5) .. Go ahead and click the URL to try it! https://api.testnet-0bsnetwork.com/v0/transactions/data?key=plantid&type=string&value=23456-f344f3&timeStart=2019-05-27&limit=5 We can see we get 5 results, and only data for that plant based on its plantId, we can see the Temp, Humidity and Soil Moisture. If we now want to get the next 5 records, we take the 'lastCursor' value of the response, and use it for the 'after' paramter in the next call https://api.testnet-0bsnetwork.com/v0/transactions/data?key=plantid&type=string&value=23456-f344f3&timeStart=2019-05-27&limit=5&after=MjAxOS0wNS0yOVQwNDo1MTowNS42NzJaOjoyZnA2OUJEVjJ3M0tjZ1h0eWozdGJrSER1b3g0NnNtdDFUOUNKcWh3NGtDajo6ZGVzYw== This now gives us the next 5 records.. we could continue this until we react the end of the data (response.data.count < 5) Note: For UI apps its best to only request what the user is viewing on the screen and make subsequent calls to update, most grids support this style of paging. For back end, you can request in chunks of 1000, or run your own data service to increase this limit. Finally, all data is always returned with its transactionID, so any transaction can be verififed on the blockchain using any or your own node!","title":"Data Service API"},{"location":"dataservice/#data-service-api","text":"Our data service API stores information about the blockchain, data, and trading. We host a public version of the API, and if you need more limits (Public API limits number of results in 1 page) you can also run your own dockerised version of this API. You can use this API to, for example, get a list of all data submitted on an account within 24 hours. It's much quicker and easier than using the Node API where you would have to pull a list of all blocks and transactions and locate the right data. The documentation for the API is located at; https://api.testnet-0bsnetwork.com/docs Below is a demonstration of using the API","title":"Data Service API"},{"location":"dataservice/#demo","text":"Here's a quick demo of our data API. This is a small docker container that runs alongside a node (NodeJS + PostGreSQL) and either you could run your own if your data querying requirements are large, or use our public one for smaller queries (There's smaller limits in place on the public one) So, Lets say we want to get all data transactions for a particular ID, in this case, I've been saving data from my orange tree, which has a 'plantId' of '23456-f344f3' So the filters we have available on the data transaction endpoint are as follows sender - public address of the data transaction sender timeStart - Start Time (e.g. 2019-05-29T03:51:05.303Z) or just date timeEnd - End Time (As Above) key - Filter by Key type - Filter by data type value - Filer by value after - Insert the previous pages cursor (lastCursor) to get the next set of records (depending on limit) limit - How many to return (Default 100 Max 1000) So, if we want to get all data transactions on the 27th May for my plant, we can query like this (Lets say we want them in pages of 5) .. Go ahead and click the URL to try it! https://api.testnet-0bsnetwork.com/v0/transactions/data?key=plantid&type=string&value=23456-f344f3&timeStart=2019-05-27&limit=5 We can see we get 5 results, and only data for that plant based on its plantId, we can see the Temp, Humidity and Soil Moisture. If we now want to get the next 5 records, we take the 'lastCursor' value of the response, and use it for the 'after' paramter in the next call https://api.testnet-0bsnetwork.com/v0/transactions/data?key=plantid&type=string&value=23456-f344f3&timeStart=2019-05-27&limit=5&after=MjAxOS0wNS0yOVQwNDo1MTowNS42NzJaOjoyZnA2OUJEVjJ3M0tjZ1h0eWozdGJrSER1b3g0NnNtdDFUOUNKcWh3NGtDajo6ZGVzYw== This now gives us the next 5 records.. we could continue this until we react the end of the data (response.data.count < 5) Note: For UI apps its best to only request what the user is viewing on the screen and make subsequent calls to update, most grids support this style of paging. For back end, you can request in chunks of 1000, or run your own data service to increase this limit. Finally, all data is always returned with its transactionID, so any transaction can be verififed on the blockchain using any or your own node!","title":"Demo"},{"location":"fullnode/","text":"Full Node Operation There are various ways and reasons to run a full node, however here lets just concentrate on setting one up for development purposes. You can find more details on more permanent methods, or staking on our main website. The quick start steps to get up and running on testnet are as follows; sudo apt-get install openjdk-8-jdk download the jar file and zbs-testnet.conf from here for the latest release; https://github.com/0bsnetwork/Zbs/releases ``` java -jar zbs-all-x.x.x-jar zbs-testnet.conf This will fire up a node in a window. Follow instructions in Full Node API to enable the API. We have also made a video on Testnet Node installation and setup under Debian-based GNU/Linux: https://youtu.be/Ypi1zxraXkk","title":"Full Node Operation"},{"location":"fullnode/#full-node-operation","text":"There are various ways and reasons to run a full node, however here lets just concentrate on setting one up for development purposes. You can find more details on more permanent methods, or staking on our main website. The quick start steps to get up and running on testnet are as follows; sudo apt-get install openjdk-8-jdk download the jar file and zbs-testnet.conf from here for the latest release; https://github.com/0bsnetwork/Zbs/releases ``` java -jar zbs-all-x.x.x-jar zbs-testnet.conf This will fire up a node in a window. Follow instructions in Full Node API to enable the API. We have also made a video on Testnet Node installation and setup under Debian-based GNU/Linux: https://youtu.be/Ypi1zxraXkk","title":"Full Node Operation"},{"location":"glossary/","text":"Glossary Term Description Node A network full node, that processes blocks and transactions POS Proof of Stake IDE Integrated Development Environment Smart Contract Code that is executed on an address or asset once deployed to the network Account / Address Address that identifies a wallet ZBS Our utility Coin/Token that operates the platform Fee A small payment that is made for conducting a transaction Generating / Mining / Forging Creating a block, when a node is chosen to create the next block MicroBlock A microblock is formed every 5 seconds, until the block is signed and broadcast Please let us know if you are unsure of any term and we will add it here!","title":"Glossary"},{"location":"glossary/#glossary","text":"Term Description Node A network full node, that processes blocks and transactions POS Proof of Stake IDE Integrated Development Environment Smart Contract Code that is executed on an address or asset once deployed to the network Account / Address Address that identifies a wallet ZBS Our utility Coin/Token that operates the platform Fee A small payment that is made for conducting a transaction Generating / Mining / Forging Creating a block, when a node is chosen to create the next block MicroBlock A microblock is formed every 5 seconds, until the block is signed and broadcast Please let us know if you are unsure of any term and we will add it here!","title":"Glossary"},{"location":"java/","text":"ZbsJava zbsjava A Java library for interacting with the zbsnetwork blockchain. Supports node interaction, offline transaction signing, Matcher orders, and creating addresses and keys. Using zbsjava in your project Use the library from GitHub: https://github.com/0bsnetwork/zbsjava Or Use the JAR file here Either build the JAR with SBT or Import the files into your project structure (Expecially with android, as you will need to manage some dependancy differences) Basic Usage Create an account from a private key: String seed = \"health lazy lens fix dwarf salad breeze myself silly december endless rent faculty report beyond\"; PrivateKeyAccount account = PrivateKeyAccount.fromSeed(seed, 0, Account.MAINNET); byte[] publicKey = account.getPublicKey(); String address = account.getAddress(); Data Transaction: String seed = \"health lazy lens fix dwarf salad breeze myself silly december endless rent faculty report beyond\"; PrivateKeyAccount account = PrivateKeyAccount.fromSeed(seed, 0, Account.MAINNET); List<DataEntry<?>> data = new LinkedList<DataEntry<?>>(); data.add(new DataEntry.StringEntry(\"Tree ID\", \"Tree Data\")); Node node = null; try { node = new Node(\"https://nodes.testnet-0bsnetwork.com/\", \"T\".charAt(0)); String txId = node.data(account, data,300_000 ); } catch (URISyntaxException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } Create a Node and learn a few things about blockchain: Node node = new Node(\"https://nodes.testnet-0bsnetwork.com/\", Account.TESTNET); System.out.println(\"Current height is \" + node.getHeight()); System.out.println(\"My balance is \" + node.getBalance(address)); System.out.println(\"With 100 confirmations: \" + node.getBalance(address, 100)); Send some money to a buddy: String buddy = \"3N9gDFq8tKFhBDBTQxR3zqvtpXjw5wW3syA\"; String txId = node.transfer(account, buddy, 1_00000000, 100_000, \"Here's for you\"); Set a script on an account. Be careful with the script you pass here, as it may lock the account forever! String setScriptTxId = node.setScript(alice, \"tx.type == 13 && height > \" + height, Account.MAINNET, SCRIPT_FEE); Sign a transaction offline: Transaction tx = Transaction.makeTransferTx(account, buddy, 1_00000000, Asset.ZBS, 100_000, Asset.ZBS, \"\"); System.out.println(\"JSON encoded data: \" + tx.getJson()); System.out.println(\"Server endpoint to send this JSON to: \" + tx.getEndpoint()); Now send it from an online machine: node.send(tx); Create a DEX order: Node matcher = new Node(\"https://nodes.testnet-0bsnetwork.com\", Account.MAINNNET); String matcherKey = matcher.getMatcherKey(); String zbtcId = \"Fmg13HEHJHuZYbtJq8Da8wifJENq8uBxDuWoP9pVe2Qe\"; Order order = matcher.createOrder(alice, matcherKey, new AssetPair(Asset.ZBS, zbtcId), // buy 10 ZBS at 0.00090000 ZBTC each Order.Type.BUY, 90_000, 10 * Asset.TOKEN, // make order valid for 1 hour System.currentTimeMillis() + 3_600_000, MATCHER_FEE); System.out.printf(\"Filed order \" + order.id); There are some examples under src/examples/java . Building the library To build from scratch, run mvn clean package The outputs are placed under the target directory.","title":"Java Library"},{"location":"java/#zbsjava","text":"","title":"ZbsJava"},{"location":"java/#zbsjava_1","text":"A Java library for interacting with the zbsnetwork blockchain. Supports node interaction, offline transaction signing, Matcher orders, and creating addresses and keys.","title":"zbsjava"},{"location":"java/#using-zbsjava-in-your-project","text":"Use the library from GitHub: https://github.com/0bsnetwork/zbsjava Or Use the JAR file here Either build the JAR with SBT or Import the files into your project structure (Expecially with android, as you will need to manage some dependancy differences)","title":"Using zbsjava in your project"},{"location":"java/#basic-usage","text":"Create an account from a private key: String seed = \"health lazy lens fix dwarf salad breeze myself silly december endless rent faculty report beyond\"; PrivateKeyAccount account = PrivateKeyAccount.fromSeed(seed, 0, Account.MAINNET); byte[] publicKey = account.getPublicKey(); String address = account.getAddress(); Data Transaction: String seed = \"health lazy lens fix dwarf salad breeze myself silly december endless rent faculty report beyond\"; PrivateKeyAccount account = PrivateKeyAccount.fromSeed(seed, 0, Account.MAINNET); List<DataEntry<?>> data = new LinkedList<DataEntry<?>>(); data.add(new DataEntry.StringEntry(\"Tree ID\", \"Tree Data\")); Node node = null; try { node = new Node(\"https://nodes.testnet-0bsnetwork.com/\", \"T\".charAt(0)); String txId = node.data(account, data,300_000 ); } catch (URISyntaxException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } Create a Node and learn a few things about blockchain: Node node = new Node(\"https://nodes.testnet-0bsnetwork.com/\", Account.TESTNET); System.out.println(\"Current height is \" + node.getHeight()); System.out.println(\"My balance is \" + node.getBalance(address)); System.out.println(\"With 100 confirmations: \" + node.getBalance(address, 100)); Send some money to a buddy: String buddy = \"3N9gDFq8tKFhBDBTQxR3zqvtpXjw5wW3syA\"; String txId = node.transfer(account, buddy, 1_00000000, 100_000, \"Here's for you\"); Set a script on an account. Be careful with the script you pass here, as it may lock the account forever! String setScriptTxId = node.setScript(alice, \"tx.type == 13 && height > \" + height, Account.MAINNET, SCRIPT_FEE); Sign a transaction offline: Transaction tx = Transaction.makeTransferTx(account, buddy, 1_00000000, Asset.ZBS, 100_000, Asset.ZBS, \"\"); System.out.println(\"JSON encoded data: \" + tx.getJson()); System.out.println(\"Server endpoint to send this JSON to: \" + tx.getEndpoint()); Now send it from an online machine: node.send(tx); Create a DEX order: Node matcher = new Node(\"https://nodes.testnet-0bsnetwork.com\", Account.MAINNNET); String matcherKey = matcher.getMatcherKey(); String zbtcId = \"Fmg13HEHJHuZYbtJq8Da8wifJENq8uBxDuWoP9pVe2Qe\"; Order order = matcher.createOrder(alice, matcherKey, new AssetPair(Asset.ZBS, zbtcId), // buy 10 ZBS at 0.00090000 ZBTC each Order.Type.BUY, 90_000, 10 * Asset.TOKEN, // make order valid for 1 hour System.currentTimeMillis() + 3_600_000, MATCHER_FEE); System.out.printf(\"Filed order \" + order.id); There are some examples under src/examples/java .","title":"Basic Usage"},{"location":"java/#building-the-library","text":"To build from scratch, run mvn clean package The outputs are placed under the target directory.","title":"Building the library"},{"location":"javascript/","text":"Javascript Library Using this library you can easily create and sign transactions for 0bsnetwork blockchain. It also allows you to multi-sign existing transactions or create them without signature at all. You can download a sample project here that contains code for all transactions as per below. (Remember to npm install first) Transactions The idea is really simple - you create transaction and sign it from a minimal set of required params. If you want to create a Transfer transaction the minimum you need to provide is amount and recipient as defined in Transfer params : const { transfer } = require('@0bsnetwork/zbs-transactions') const seed = 'some example seed phrase' const signedTranserTx = transfer({ amount: 1, recipient: '3P6fVra21KmTfWHBdib45iYV6aFduh4WwC2', //Timestamp is optional but it was overridden, in case timestamp is not provided it will fallback to Date.now(). You can set any oftional params yourself. go check full docs timestamp: 1536917842558 }, seed) Output will be a signed transfer transaction: { id: '8NrUwgKRCMFbUbqXKQAHkGnspmWHEjKUSi5opEC6Havq', type: 4, version: 2, recipient: '3P6fVra21KmTfWHBdib45iYV6aFduh4WwC2', attachment: undefined, feeAssetId: undefined, assetId: undefined, amount: 1, fee: 100000, senderPublicKey: '6nR7CXVV7Zmt9ew11BsNzSvVmuyM5PF6VPbWHW9BHgPq', timestamp: 1536917842558, proofs: [ '25kyX6HGjS3rkPTJRj5NVH6LLuZe6SzCzFtoJ8GDkojY9U5oPfVrnwBgrCHXZicfsmLthPUjTrfT9TQL2ciYrPGE' ] } You can also create transaction, but not sign it: const unsignedTransferTx = transfer({ amount: 1, recipient: '3P6fVra21KmTfWHBdib45iYV6aFduh4WwC2', //senderPublicKey is required if you omit seed senderPublicKey: '6nR7CXVV7Zmt9ew11BsNzSvVmuyM5PF6VPbWHW9BHgPq' }) Now you are able to POST it to 0bsNetwork or store for future purpose or you can add another signature from other party: const otherPartySeed = 'other party seed phrase' const transferSignedWithTwoParties = transfer(signedTranserTx, seed) So now there are two proofs: { id: '8NrUwgKRCMFbUbqXKQAHkGnspmWHEjKUSi5opEC6Havq', type: 4, version: 2, recipient: '3P6fVra21KmTfWHBdib45iYV6aFduh4WwC2', attachment: undefined, feeAssetId: undefined, assetId: undefined, amount: 1, fee: 100000, senderPublicKey: '6nR7CXVV7Zmt9ew11BsNzSvVmuyM5PF6VPbWHW9BHgPq', timestamp: 1536917842558, proofs: [ '25kyX6HGjS3rkPTJRj5NVH6LLuZe6SzCzFtoJ8GDkojY9U5oPfVrnwBgrCHXZicfsmLthPUjTrfT9TQL2ciYrPGE', 'CM9emPzpe6Ram7ZxcYax6s7Hkw6698wXCMPSckveFAS2Yh9vqJpy1X9nL7p4RKgU3UEa8c9RGXfUK6mFFq4dL9z' ] } Broadcast To send transaction you can use either node api or broadcast helper function: const {broadcast} = require('@0bsnetwork/zbs-transaction'); const nodeUrl = 'https://node1.testnet-0bsnetwork.com'; broadcast(signedTx, nodeUrl).then(resp => console.log(resp)) Transaction Examples Issue const { issue, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = issue( { name: 'MyTestToken', description: 'My New Token', quantity: 50000, chainId: 'T' }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`)); Reissue: const { reissue, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = reissue({ quantity: 5000000, assetId: '5cfyua2DBmLcWYjh6D3k8ra3xNc6Ap47BSGr9rujciy6', reissuable: false, chainId: 'T' }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`)); Transfer Transaction const { transfer, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = transfer({ amount: 1, recipient: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', fee: 5000000 }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`)); Burn Transaction Burning tokens can be useful for systems where a token is used to activate or fund a service and once the service has been used the token can be burnt. const constants = require('./constants') const { burn, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = burn({ quantity: 1, assetId: 'BiuhdjnH9qxgfax52zXgJw3b5ArxCdA4q8kYECqWoEYT', chainId: 'T' }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`)); Exchange Transaction Lease Transaction const { lease, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = lease( { amount: 100000, recipient: '3NBTZJ6BpuQeRCciQzYRVrFwyhrUcsf6f6M', }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`)); Lease Cancel const { cancelLease, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = cancelLease( { leaseId: 'HxJrij7Ba7ojaovjrZcvAaXAwMBMr9BkAyXLsdiiWtkF', chainId: 'T' }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`)); Create Alias const { alias, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = alias( { alias: 'New Alias', chainId: 'T', fee: 100000 }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`)); Mass Transfer const { massTransfer, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = massTransfer({transfers: [ { amount: 1, recipient: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', fee: 1000000 }, { amount: 1, recipient: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', fee: 1000000 }, ]}, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`)); Data const { data, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = data( { data: [ { key: 'integerVal', value: 1 }, { key: 'booleanVal', value: true }, { key: 'stringVal', value: 'hello' }, { key: 'binaryVal', value: [1, 2, 3, 4] } ] }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`)); SetScript CustomFee Enable Set Asset Invoke Script Index Example code: const { transfer, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = transfer({ amount: 1, recipient: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', fee: 5000000, chainId: 'T' }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`)); Signing Transactions Signing transactions manually is quite complex, and usually its best to use a library to do so, however if you find you dont have a library available for your platform of choice, you may need to do it manually. The process involves concatenting the byte values of fields from the transaction to create a long byte array, and signing this using Curve25519 and your private key, and inserting this into the transaction payload. Rather than include excessive details here on how to do that, the below code sample in C Sharp should be readable enough to understand how the process works, and you can also examine the code of our other libraries as they are all open source. If you need specific details or guidance, please do contact us using the details on the Front Page Sponsorship const { sponsorship, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = sponsorship( { assetId: 'BiuhdjnH9qxgfax52zXgJw3b5ArxCdA4q8kYECqWoEYT', minSponsoredAssetFee: 100, }, constants.DATA.SEED) broadcast(signedTx, constants.DATA.NODE_URL) .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`));","title":"Javascript Libraries"},{"location":"javascript/#javascript-library","text":"Using this library you can easily create and sign transactions for 0bsnetwork blockchain. It also allows you to multi-sign existing transactions or create them without signature at all. You can download a sample project here that contains code for all transactions as per below. (Remember to npm install first)","title":"Javascript Library"},{"location":"javascript/#transactions","text":"The idea is really simple - you create transaction and sign it from a minimal set of required params. If you want to create a Transfer transaction the minimum you need to provide is amount and recipient as defined in Transfer params : const { transfer } = require('@0bsnetwork/zbs-transactions') const seed = 'some example seed phrase' const signedTranserTx = transfer({ amount: 1, recipient: '3P6fVra21KmTfWHBdib45iYV6aFduh4WwC2', //Timestamp is optional but it was overridden, in case timestamp is not provided it will fallback to Date.now(). You can set any oftional params yourself. go check full docs timestamp: 1536917842558 }, seed) Output will be a signed transfer transaction: { id: '8NrUwgKRCMFbUbqXKQAHkGnspmWHEjKUSi5opEC6Havq', type: 4, version: 2, recipient: '3P6fVra21KmTfWHBdib45iYV6aFduh4WwC2', attachment: undefined, feeAssetId: undefined, assetId: undefined, amount: 1, fee: 100000, senderPublicKey: '6nR7CXVV7Zmt9ew11BsNzSvVmuyM5PF6VPbWHW9BHgPq', timestamp: 1536917842558, proofs: [ '25kyX6HGjS3rkPTJRj5NVH6LLuZe6SzCzFtoJ8GDkojY9U5oPfVrnwBgrCHXZicfsmLthPUjTrfT9TQL2ciYrPGE' ] } You can also create transaction, but not sign it: const unsignedTransferTx = transfer({ amount: 1, recipient: '3P6fVra21KmTfWHBdib45iYV6aFduh4WwC2', //senderPublicKey is required if you omit seed senderPublicKey: '6nR7CXVV7Zmt9ew11BsNzSvVmuyM5PF6VPbWHW9BHgPq' }) Now you are able to POST it to 0bsNetwork or store for future purpose or you can add another signature from other party: const otherPartySeed = 'other party seed phrase' const transferSignedWithTwoParties = transfer(signedTranserTx, seed) So now there are two proofs: { id: '8NrUwgKRCMFbUbqXKQAHkGnspmWHEjKUSi5opEC6Havq', type: 4, version: 2, recipient: '3P6fVra21KmTfWHBdib45iYV6aFduh4WwC2', attachment: undefined, feeAssetId: undefined, assetId: undefined, amount: 1, fee: 100000, senderPublicKey: '6nR7CXVV7Zmt9ew11BsNzSvVmuyM5PF6VPbWHW9BHgPq', timestamp: 1536917842558, proofs: [ '25kyX6HGjS3rkPTJRj5NVH6LLuZe6SzCzFtoJ8GDkojY9U5oPfVrnwBgrCHXZicfsmLthPUjTrfT9TQL2ciYrPGE', 'CM9emPzpe6Ram7ZxcYax6s7Hkw6698wXCMPSckveFAS2Yh9vqJpy1X9nL7p4RKgU3UEa8c9RGXfUK6mFFq4dL9z' ] }","title":"Transactions"},{"location":"javascript/#broadcast","text":"To send transaction you can use either node api or broadcast helper function: const {broadcast} = require('@0bsnetwork/zbs-transaction'); const nodeUrl = 'https://node1.testnet-0bsnetwork.com'; broadcast(signedTx, nodeUrl).then(resp => console.log(resp))","title":"Broadcast"},{"location":"javascript/#transaction-examples","text":"","title":"Transaction Examples"},{"location":"javascript/#issue","text":"const { issue, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = issue( { name: 'MyTestToken', description: 'My New Token', quantity: 50000, chainId: 'T' }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`));","title":"Issue"},{"location":"javascript/#reissue","text":"const { reissue, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = reissue({ quantity: 5000000, assetId: '5cfyua2DBmLcWYjh6D3k8ra3xNc6Ap47BSGr9rujciy6', reissuable: false, chainId: 'T' }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`));","title":"Reissue:"},{"location":"javascript/#transfer-transaction","text":"const { transfer, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = transfer({ amount: 1, recipient: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', fee: 5000000 }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`));","title":"Transfer Transaction"},{"location":"javascript/#burn-transaction","text":"Burning tokens can be useful for systems where a token is used to activate or fund a service and once the service has been used the token can be burnt. const constants = require('./constants') const { burn, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = burn({ quantity: 1, assetId: 'BiuhdjnH9qxgfax52zXgJw3b5ArxCdA4q8kYECqWoEYT', chainId: 'T' }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`));","title":"Burn Transaction"},{"location":"javascript/#exchange-transaction","text":"","title":"Exchange Transaction"},{"location":"javascript/#lease-transaction","text":"const { lease, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = lease( { amount: 100000, recipient: '3NBTZJ6BpuQeRCciQzYRVrFwyhrUcsf6f6M', }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`));","title":"Lease Transaction"},{"location":"javascript/#lease-cancel","text":"const { cancelLease, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = cancelLease( { leaseId: 'HxJrij7Ba7ojaovjrZcvAaXAwMBMr9BkAyXLsdiiWtkF', chainId: 'T' }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`));","title":"Lease Cancel"},{"location":"javascript/#create-alias","text":"const { alias, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = alias( { alias: 'New Alias', chainId: 'T', fee: 100000 }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`));","title":"Create Alias"},{"location":"javascript/#mass-transfer","text":"const { massTransfer, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = massTransfer({transfers: [ { amount: 1, recipient: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', fee: 1000000 }, { amount: 1, recipient: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', fee: 1000000 }, ]}, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`));","title":"Mass Transfer"},{"location":"javascript/#data","text":"const { data, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = data( { data: [ { key: 'integerVal', value: 1 }, { key: 'booleanVal', value: true }, { key: 'stringVal', value: 'hello' }, { key: 'binaryVal', value: [1, 2, 3, 4] } ] }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`));","title":"Data"},{"location":"javascript/#setscript","text":"","title":"SetScript"},{"location":"javascript/#customfee-enable","text":"","title":"CustomFee Enable"},{"location":"javascript/#set-asset","text":"","title":"Set Asset"},{"location":"javascript/#invoke-script","text":"","title":"Invoke Script"},{"location":"javascript/#index","text":"Example code: const { transfer, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = transfer({ amount: 1, recipient: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', fee: 5000000, chainId: 'T' }, \"Write your SEED here\") broadcast(signedTx, \"https://node1.testnet-0bsnetwork.com\") .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`));","title":"Index"},{"location":"javascript/#signing-transactions","text":"Signing transactions manually is quite complex, and usually its best to use a library to do so, however if you find you dont have a library available for your platform of choice, you may need to do it manually. The process involves concatenting the byte values of fields from the transaction to create a long byte array, and signing this using Curve25519 and your private key, and inserting this into the transaction payload. Rather than include excessive details here on how to do that, the below code sample in C Sharp should be readable enough to understand how the process works, and you can also examine the code of our other libraries as they are all open source. If you need specific details or guidance, please do contact us using the details on the Front Page","title":"Signing Transactions"},{"location":"javascript/#sponsorship","text":"const { sponsorship, broadcast } = require('@0bsnetwork/zbs-transactions') const signedTx = sponsorship( { assetId: 'BiuhdjnH9qxgfax52zXgJw3b5ArxCdA4q8kYECqWoEYT', minSponsoredAssetFee: 100, }, constants.DATA.SEED) broadcast(signedTx, constants.DATA.NODE_URL) .then(resp => console.log(resp)) .catch(e => console.error(`.catch(${e})`));","title":"Sponsorship"},{"location":"link/","text":"0bsLink v1.0.9 0bsLink is an extension that allows users to securely interact with 0bsnetwork-enabled web services from the browser. Seed phrases and private keys are encrypted and stored within the extension and cannot be accessed by online dApps and services, making sure that users' funds are always protected from hackers and malicious websites. Completion of a transaction doesn't require entering any sensitive information. 0bsLink is designed for convenience, so users can sign transactions with just a couple of clicks. Users can create multiple wallets and switch between them easily. And if a user ever forgets the password to the account, it can be recovered from the seed phrase. This service is currently in beta and is not yet published to the chrome and firefox app store (Edge and Opera coming soon) However, you can still use the service to develop your application. The extensions are located here; Chrome FireFox You can install the chrome extention manually as so; Visit chrome://extensions/ Click 'Load Unpacked' Select your folder Setup 0bsLink - Remember to select TestNet if you need to! 0bsLink API On browser pages that operate under the http/https with 0bsLink extension installed, the 0bsLink global object becomes available, featuring the following methods: auth publicState signAndPublishCancelOrder signAndPublishOrder signAndPublishTransaction signCancelOrder signOrder signTransaction signRequest signTransactionPackage on All methods, except for \"on\" operate asynchronously and return promises . In 0bsLink, for greater security and ease of use, each new website using API has to be allowed by the user. At the first attempt to use API (except \" on\" ), the user will see a request to allow that website's access to 0bsLink. If the user agrees to allow access, the website is considered trusted and can use API on its pages. Otherwise, the website is blocked, and an error message will be displayed in response to all requests {message: \"Api rejected by user\", code: 12}. The users won't see new notifications. To grant access, the user will mark the website as trusted in the interface. Description of methods publicState If a website is trusted, 0bsLink public data are returned. Example: zbsLink.publicState() .then(state => { console.log(state); //displaying the result in the console /*...processing data */ }).catch(error => { console.error(error); // displaying the result in the console /*...processing errors */ }) or const getPublicState = async () => { try { const state = await zbsLink.publicState(); console.log(state); // displaying the result in the console /*... processing data*/ } catch(error) { console.error(error); // displaying the result in the console /*... processing errors */ } } const result = await getPublicState(); REPLY { \"initialized\": true, \"locked\": true, \"account\": { \"name\": \"foo\", \"publicKey\": \"bar\", \"address\": \"address\", \"networkCode\": \"network byte\", \"balance\": { \"available\": \"balance in zbs\", \"leasedOut\": \"leased balance\" } }, \"network\": { \"code\": \"T\", \"server\": \"https://nodes.testnet-0bsnetwork.com/\", \"matcher\": \"https://matcher.testnet-0bsnetwork.com/\" }, \"messages\": [], \"txVersion\": { \"3\": [ 2 ], \"4\": [ 2 ], \"5\": [ 2 ], ... } } Description of query return fields initialized - boolean keeper initialized locked - boolean keeper in wait mode account \u2013 current account, if the user allowed access to the website, or null network \u2013 current 0bsnetwork, node and matcher addresses messages \u2013 signature request statuses txVersion \u2013 available transaction versions for each type Possible errors { message: \"Init 0bsLink and add account\" } \u2013 0bsLink is not initialized { message: \"Add 0bsLink account\" } \u2013 0bsLink accessed, but there are no accounts { message: \"User denied message\" } \u2013 the user denied the website operation with 0bsLink on Allows subscribing to 0bsLink events. Supports events: update \u2013 subscribe to updates of the state Example: zbsLink.on(\"update\", state => { //state object as from zbsLink.publicState }); If a website is not trusted, events won't show. auth This is a method for obtaining a signature of authorization data while verifying 0bsnetwork user. Example: const authData = { data: \"Auth on my site\" }; zbsLink.auth(authData) .then(auth => { console.log(state); //displaying the result on the console /*...processing data */ }).catch(error => { console.error(error); // displaying the result on the console /*...processing errors */ }) or const getAuthData = async authData => { try { const state = await zbsLink.auth(authData); console.log(state); // displaying the result on the console /*... processing data */ } catch(error) { console.error(error); // displaying the result on the console /*... processing errors */ } } const authData = { data: \"Auth on my site\" }; getAuthData(authData); auth facilitates input of the following data name \u2013 name of the service (optional field) data \u2013 a line with any data (required field) referrer \u2013 a websites' full URL for redirect (optional field) icon \u2013 path to the logo relative to the referrer or origin of the website (optional field) successPath \u2013 relative path to the website's Auth API (optional field) Example const authData = { data: \"Generated string from server\", name: \"My test App\", icon: \"/img/icons/zbs_logo.svg\", referrer: \"https://client.testnet-0bsnetwork.com/\", successPath: \"login\" }; zbsLink.auth(authData).then((data) => { //data \u2013 data from 0bsLink //verifying signature and saving the address... console.log(data); }).catch((error) => { //processing the error }); If the verification is successful, 0bsLink will return in the promise an object containing data for signature verification: host \u2013 a host that requested a signature name \u2013 the name of an application that requested a signature prefix \u2013 a prefix participating in the signature address \u2013 an address in 0bsnetwork publicKey \u2013 the user's public key signature - signature version \u2013 API version ERRORS {message: \"Invalid data\", data: \"[{\"field\":\"data\",\"type\":\"string\",\"message\":\"field is required\"}]\", code: 9} \u2013 signature data contain errors {message: \"User denied message\", code: 10} \u2013 the user denied the request {message: \"Api rejected by user\", code: 12} - the website is not trusted signTransaction A method for signing transactions in 0bsNetwork. Example: const txData = { type: 4, data: { amount: { assetId: \"ZBS\", tokens: \"1.567\" }, fee: { assetId: \"ZBS\", tokens: \"0.001\" }, recipient: \"test\" } }; zbsLink.signTransaction(txData).then((data) => { //data \u2013 a line ready for sending to 0bsNetwork's node (server) }).catch((error) => { //Processing errors }); API returns lines, not an object, as in javascript precision is lost in operation with 8-byte integers. A description of supported transaction types is below. In the example, we are signing a transaction for transferring ZBS to the alias test in 0bsnetwork. REPLY {\"version\":2,\"assetId\":\"\", \"amount\":156700000,\"feeAssetId\":\"\",fee:100000, \"recipient\":\"recipient\",\"attachment\":\"\", \"timestamp\":1548770230589,\"senderPublicKey\":\"public key\",\"proofs\":[\"signature\"],\"type\":4} ERRORS {message: \"User denied message\", code: 10} \u2013 The user denied the request. {message: \"Api rejected by user\", code: 12} \u2013 The website is not trusted. {message: \"Invalid data\", data: \"Reason\", code: 9} \u2013 invalid/incomplete request data. signAndPublishTransaction This is similar to \" signTransaction\" , but it also broadcasts a transaction to the blockchain. Example: const txData = { type: 4, data: { amount: { assetId: \"ZBS\", tokens: \"1.567\" }, fee: { assetId: \"ZBS\", tokens: \"0.001\" }, recipient: \"test\" } }; zbsLink.signAndPublishTransaction(txData).then((data) => { //data - a line ready for sending to 0bsNetwork's node (server) }).catch((error) => { //processing errors }); REPLY A reply from 0bsNetwork returns as a line containing the entire past transaction. ERRORS Same as signTransaction {message: \"Filed request\", data: \"Error description\", code: 15} \u2013 a request was signed but not broadcasted signTransactionPackage A package transaction signature. Sometimes several transactions need to be simultaneously signed, and for users' convenience, up to seven transactions at ones could be signed. Only certain types of transactions are permitted: 3 \u2013 token issue 4 \u2013 token transfer 5 \u2013 token re-issue 6 \u2013 token burning 10 \u2013 creating an alias for an address in 0bsNetwork 11 \u2013 mass transfer 12 - DataTransaction Example: const name = \"For Test\"; const tx = [{ type: 4, data: { amount: { assetId: \"ZBS\", tokens: \"1.567\" }, fee: { assetId: \"ZBS\", tokens: \"0.001\" }, recipient: \"test\" }},{ type: 4, data: { amount: { assetId: \"ZBS\", tokens: \"0.51\" }, fee: { assetId: \"ZBS\", tokens: \"0.001\" }, recipient: \"merry\" } }]; zbsLink.signTransactionPackage(tx, name) Sign two transaction: Transfer 1.567 ZBS to the alias test Transfer 0.1 ZBS to the alias merry REPLY A unit of two lines \u2013 transactions that are signed and ready to be broadcasted. ERRORS Same as in \" signTransaction \" Every user of 0bsNetwork has a state (balances, assets, data, scripts), and every past transactions changes these data. \\ In 0bsLink API it is different from NODE REST API . signTransaction , signAndPublishTransaction accept transactions as follows { type: number //transaction type, data: { ... //transaction data } } Legend keys optional field, data are automatically supplied from zbsLink. \\ [x,y] \u2013 length limit from x to y. \\ [,x] \u2013 length limit to x. \\ [y,] \u2013 length limit from y. \\ [x-y] \u2013 number from x to y. x/y - x or y. (JLM) - JAVA LONG MAX = 9 223 372 036 854 775 807 \\ MoneyLike - price MoneyLike could look as: { tokens: 1, assetId: \"ZBS\" } { coins: 100000000, assetId: \"ZBS\" } ; In both messages, the same price of 1 ZBS is indicated. You can easily convert coins into tokens and back, if you know in what asset the price is indicated and you have received its precision tokens = coins / (10 ** precision) \\ If the field contains other types than MoneyLike, for instance, string/MoneyLike , the sum is indicated as a number in coins . Type 3 ISSUE \u2013 token issue name [4, 16] string \u2013 token name, description [0, 1000] string \u2013 token description, quantity [0 - (JLM)] number/string - quantity, precision [0 - 8] number - precision, reissuable true|false \u2013 reissuble, fee MoneyLike -fee *script string \u2013 asset script *senderPublicKey string \u2013 sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 3, data: { \"name\": \"Best Token\", \"description\": \"Greate token\", \"quantity\": 1000000, \"precision\": 2, \"reissuable\": true, fee: { \"tokens\": \"1\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've created my asset!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, we are issuing a new asset in the quantity of 1,000,000, and your balance will show 10,000.00 Best Token \u0422ype 4 TRANSFER \u2013 asset transfer amount MoneyLike - amount, recipient string \u2013 recipient's address or alias attachment [,140 bytes \u0432 base58] string \u2013 additional info fee MoneyLike - fee *senderPublicKey string \u2013 sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 4, data: { amount: { tokens: \"3.3333333\", assetId: \"ZBS\" }, fee: { tokens: \"0.001\", assetId: \"ZBS\"}, recipient: \"merry\" } }).then((tx) => { console.log(\"Hurray! I've been able to send ZBS!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); \u0422ype 5 REISSUE \u2013 token reissue assetId string - \"asset ID\", quantity [0 - (JLM)] number/string/MoneyLike - quantity, reissuable false \u2013 deny reissue fee MoneyLike -fee *senderPublicKey string \u2013 sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 5, data: { \"quantity\": 1000, \"assetId\": \"8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS\", \"reissuable\": true, fee: { \"tokens\": \"1\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've reissued my asset!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, we are re-issuing a new asset in the quantity of 1,000,000, and your balance will show 10,000.00 Best Token \u0422ype 6 BURN \u2013 burning tokens assetId string \u2013 asset ID, amount [0 - (JLM)] number/string/MoneyLike - quantity, fee MoneyLike -fee *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 6, data: { amount: 1000, assetId: \"8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS\", fee: { \"tokens\": \"0.001\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've burned unneeded tokens!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, 1,000 coins are burned . \u0422ype 8 LEASE - Leasing recipient string \u2013 recipient's address or alias, amount [0 - (JLM)] number/string/MoneyLike - quantity, fee MoneyLike -fee *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 8, data: { \"amount\": 1000, \"recipient\": \"merry\", fee: { \"tokens\": \"0.001\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've been able to lease tokens!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, 0.00001000 ZBS is leased. \u0422ype 9 LEASE CANCEL \u2013 cancel leasing leaseId string \u2013 leasing transaction ID, fee MoneyLike -fee *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 9, data: { leaseId: \"6frvwF8uicAfyEfTfyC2sXqBJH7V5C8he5K4YH3BkNiS\", fee: { \"tokens\": \"0.001\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've cancelled leasing!!!\"); }).catch((error) => { console.error(\"Something went wrong \", error); }); In case of a success, the leasing transaction is cancelled. \u0422ype 10 CREATE ALIAS \u2013 creating an alias for an address alias [4, 30] string - alias fee MoneyLike -fee *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 10, data: { alias: \"testAlias\", fee: { \"tokens\": \"0.001\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! Now I have an alias!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, an alias (another name) is created. \u0422ype 11 MASS TRANSFER - a mass transfer of an asset totalAmount moneyLike \u2013 total to be sent // instead of calculating the amount you may insert { assetId: \"ID of the asset to be sent\", coins: 0}, transfers a mass of objects { recipient : string - address/alias, amount: number/string/moneyLike } fee MoneyLike -fee attachment [,140 bytes \u0432 base58] string \u2013 additional info *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 11, data: { totalAmount: { assetId: \"ZBS\", coins: 0}, transfers: [ { recipient: \"alias1\", amount: \"200000\" }, { recipient: \"alias2\", amount: \"200000\" }, ], fee: { \"tokens\": \"0.002\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've sent hi to my friends!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, 0.002 ZBS will be sent to alias1 and alias2. \u0422ype 12 DATA TRANSACTION - saving data data mass of objects type \"binary\"/string/\"integer\"/\"boolean\" - type, key string \u2013 field name value /string/string/number/boolean depends on the type fee MoneyLike - fee *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms Field: zbsLink.signAndPublishTransaction({ type: 12, data: { data: [ { key: \"string\", value: \"testVal\", type: \"string\" }, { key: \"binary\", value: \"base64:AbCd\", type: \"binary\" }, { key: \"integer\", value: 20, type: \"integer\" }, { key: \"boolean\", value: false, type: \"boolean\" }, ], fee: { \"tokens\": \"0.01\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've saved data!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, new data will be stored in the state. \u0422ype 13 SET SCRIPT \u2013 scrypting an account script string - script fee MoneyLike -fee *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms For cancelling a script the field script has to be \"\". Script development on RIDE Example: zbsLink.signAndPublishTransaction({ type: 13, data: { script: \"\", fee: { \"tokens\": \"0.04\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've cancelled a script!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, the script will be removed from the account. Example 2: zbsLink.signAndPublishTransaction({ type: 13, data: { script: \"base64:AQa3b8tH\", fee: { \"tokens\": \"0.01\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've added a script!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, a new script will be added to the account, allowing any transactions without a signature (be careful!). \u0422ype 14 Sponsored Fee Transaction - Sponsorship minSponsoredAssetFee MoneyLike \u2013 fee price in the asset. fee MoneyLike - fee *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 14, data: { minSponsoredAssetFee: { assetId: \"6frvwF8uicAfyEfTfyC2sXqBJH7V5C8he5K4YH3BkNiS\", tokens: 0.1 }, fee: { \"tokens\": \"1\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've become a sponsor!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, a transfer fee can be paid in the asset. \u0422ype 15 SET ASSET SCRIPT \u2013 setting a script to an asset assetId string \u2013 asset ID script string - [script] fee MoneyLike -fee *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms It's now impossible to cancel a script, you can only add a new script. Script development on RIDE Example: zbsLink.signAndPublishTransaction({ type: 15, data: { assetId: \"\", script: \"base64:AQa3b8tH\", fee: { \"tokens\": \"0.01\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I have reset a script to the asset!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, the asset's script will be reset. signOrder 0bsLink's method for signing an order to the matcher. As input, it accepts an object similar to a transaction like this: { type: 1002, data: { ...data } } amount MoneyLike - amount price MoneyLike - price orderType 'sell'/'buy' \u2013 order type matcherFee MoneyLike - fee (0.003 ZBS minimum), matcherPublicKey string - the public key of the exchange service expiration string/number \u2013 the order's expiration time *timestamp string/number - current time *senderPublicKey string - public key in base58 Example: zbsLink.signOrder({ type: 1002, data: { matcherPublicKey: \"7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy\", orderType: \"sell\", expiration: Date.now() + 100000, amount: { tokens: \"100\", assetId: \"ZBS\" }, price: { tokens: \"0.01\", assetId: \"8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS\" }, matcherFee: { tokens: \"0.03\", assetId: \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've signed an order!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); REPLY: A line with data for sending to the matcher. ERRORS: { message: \"User denied message\", code: 10 } \u2013 the user rejected the request { message: \"Api rejected by user\", code: 12 } \u2013 The website is not trusted { message: \"Invalid data\", data: \"Reason\", code: 9 } - invalid/incomplete request data signAndPublishOrder 0bsLink's method for creating an order to the matcher is identical to signOrder , but it also tries to send data to the matcher. REPLY: the matcher's reply line about successful creation of an order. ERRORS: Same as for signOrder {message: \"Filed request\", data: \"Error description\", code: 15} \u2013 a request has been signed, but not sent to the matcher signCancelOrder 0bsLink's method for signing cancellation of an order to the matcher. As input, it accepts an object similar to a transaction like this: { type: 1003, data: { ...data } } id string \u2013 order ID *senderPublicKey - string - sender's public key in base58 Example: zbsLink.signCancelOrder({ type: 1003, data: { id: '31EeVpTAronk95TjCHdyaveDukde4nDr9BfFpvhZ3Sap' } }); REPLY: A data line for sending to the matcher. ERRORS: { message: \"User denied message\", code: 10 } \u2013 the user rejected the request { message: \"Api rejected by user\", code: 12 } \u2013 The website is not trusted { message: \"Invalid data\", data: \"Reason\", code: 9 } - invalid/incomplete request data signAndPublishCancelOrder 0bsLink's method for cancelling an order to the matcher. It works identically to signCancelOrder , but also tries to send data to the matcher. Example: zbsLink.signAndPublishCancelOrder({ type: 1003, data: { id: '31EeVpTAronk95TjCHdyaveDukde4nDr9BfFpvhZ3Sap' } }).then(() => { console.log('Hurray! I've cancelled an order'); }).catch((error) => { console.error(\"Something went wrong\", error); }) REPLY: Data that came from the matcher ERRORS: Same as for signCancelOrder {message: \"Filed request\", data: \"Error description\", code: 15} \u2013 a request has been signed, but not sent to the matcher signRequest 0bsLink's method for signing typified data, for signing requests on various services. As input, it accepts an object similar to a transaction like this: { type: number, data: { ...data } } Currently, the method supports the following types: 1001 \u2013 signing data for a request to the matcher for your orders timestamp number/string *senderPublicKey string public key in base58 Example: zbsLink.signRequest({ type: 1001, data: { timestamp: 234234242423423 } }); REPLY: a line with a signature in base58. ERRORS: { message: \"User denied message\", code: 10 } \u2013 the user rejected the request { message: \"Api rejected by user\", code: 12 } \u2013 The website is not trusted { message: \"Invalid data\", data: \"Reason\", code: 9 } - invalid/incomplete request data 1004 \u2013 signing data for a request to Coinomat timestamp number/string Request: zbsLink.signRequest({ type: 1004, data: { timestamp: 234234242423423 } }); REPLY: a line with a signature in base58. ERRORS: { message: \"User denied message\", code: 10 } \u2013 the user rejected the request { message: \"Api rejected by user\", code: 12 } \u2013 The website is not trusted { message: \"Invalid data\", data: \"Reason\", code: 9 } - invalid/incomplete request data","title":"0bsLink"},{"location":"link/#0bslink-v109","text":"0bsLink is an extension that allows users to securely interact with 0bsnetwork-enabled web services from the browser. Seed phrases and private keys are encrypted and stored within the extension and cannot be accessed by online dApps and services, making sure that users' funds are always protected from hackers and malicious websites. Completion of a transaction doesn't require entering any sensitive information. 0bsLink is designed for convenience, so users can sign transactions with just a couple of clicks. Users can create multiple wallets and switch between them easily. And if a user ever forgets the password to the account, it can be recovered from the seed phrase. This service is currently in beta and is not yet published to the chrome and firefox app store (Edge and Opera coming soon) However, you can still use the service to develop your application. The extensions are located here; Chrome FireFox You can install the chrome extention manually as so; Visit chrome://extensions/ Click 'Load Unpacked' Select your folder Setup 0bsLink - Remember to select TestNet if you need to!","title":"0bsLink v1.0.9"},{"location":"link/#0bslink-api","text":"On browser pages that operate under the http/https with 0bsLink extension installed, the 0bsLink global object becomes available, featuring the following methods: auth publicState signAndPublishCancelOrder signAndPublishOrder signAndPublishTransaction signCancelOrder signOrder signTransaction signRequest signTransactionPackage on All methods, except for \"on\" operate asynchronously and return promises . In 0bsLink, for greater security and ease of use, each new website using API has to be allowed by the user. At the first attempt to use API (except \" on\" ), the user will see a request to allow that website's access to 0bsLink. If the user agrees to allow access, the website is considered trusted and can use API on its pages. Otherwise, the website is blocked, and an error message will be displayed in response to all requests {message: \"Api rejected by user\", code: 12}. The users won't see new notifications. To grant access, the user will mark the website as trusted in the interface.","title":"0bsLink API"},{"location":"link/#description-of-methods","text":"publicState If a website is trusted, 0bsLink public data are returned. Example: zbsLink.publicState() .then(state => { console.log(state); //displaying the result in the console /*...processing data */ }).catch(error => { console.error(error); // displaying the result in the console /*...processing errors */ }) or const getPublicState = async () => { try { const state = await zbsLink.publicState(); console.log(state); // displaying the result in the console /*... processing data*/ } catch(error) { console.error(error); // displaying the result in the console /*... processing errors */ } } const result = await getPublicState(); REPLY { \"initialized\": true, \"locked\": true, \"account\": { \"name\": \"foo\", \"publicKey\": \"bar\", \"address\": \"address\", \"networkCode\": \"network byte\", \"balance\": { \"available\": \"balance in zbs\", \"leasedOut\": \"leased balance\" } }, \"network\": { \"code\": \"T\", \"server\": \"https://nodes.testnet-0bsnetwork.com/\", \"matcher\": \"https://matcher.testnet-0bsnetwork.com/\" }, \"messages\": [], \"txVersion\": { \"3\": [ 2 ], \"4\": [ 2 ], \"5\": [ 2 ], ... } } Description of query return fields initialized - boolean keeper initialized locked - boolean keeper in wait mode account \u2013 current account, if the user allowed access to the website, or null network \u2013 current 0bsnetwork, node and matcher addresses messages \u2013 signature request statuses txVersion \u2013 available transaction versions for each type Possible errors { message: \"Init 0bsLink and add account\" } \u2013 0bsLink is not initialized { message: \"Add 0bsLink account\" } \u2013 0bsLink accessed, but there are no accounts { message: \"User denied message\" } \u2013 the user denied the website operation with 0bsLink on Allows subscribing to 0bsLink events. Supports events: update \u2013 subscribe to updates of the state Example: zbsLink.on(\"update\", state => { //state object as from zbsLink.publicState }); If a website is not trusted, events won't show. auth This is a method for obtaining a signature of authorization data while verifying 0bsnetwork user. Example: const authData = { data: \"Auth on my site\" }; zbsLink.auth(authData) .then(auth => { console.log(state); //displaying the result on the console /*...processing data */ }).catch(error => { console.error(error); // displaying the result on the console /*...processing errors */ }) or const getAuthData = async authData => { try { const state = await zbsLink.auth(authData); console.log(state); // displaying the result on the console /*... processing data */ } catch(error) { console.error(error); // displaying the result on the console /*... processing errors */ } } const authData = { data: \"Auth on my site\" }; getAuthData(authData); auth facilitates input of the following data name \u2013 name of the service (optional field) data \u2013 a line with any data (required field) referrer \u2013 a websites' full URL for redirect (optional field) icon \u2013 path to the logo relative to the referrer or origin of the website (optional field) successPath \u2013 relative path to the website's Auth API (optional field) Example const authData = { data: \"Generated string from server\", name: \"My test App\", icon: \"/img/icons/zbs_logo.svg\", referrer: \"https://client.testnet-0bsnetwork.com/\", successPath: \"login\" }; zbsLink.auth(authData).then((data) => { //data \u2013 data from 0bsLink //verifying signature and saving the address... console.log(data); }).catch((error) => { //processing the error }); If the verification is successful, 0bsLink will return in the promise an object containing data for signature verification: host \u2013 a host that requested a signature name \u2013 the name of an application that requested a signature prefix \u2013 a prefix participating in the signature address \u2013 an address in 0bsnetwork publicKey \u2013 the user's public key signature - signature version \u2013 API version ERRORS {message: \"Invalid data\", data: \"[{\"field\":\"data\",\"type\":\"string\",\"message\":\"field is required\"}]\", code: 9} \u2013 signature data contain errors {message: \"User denied message\", code: 10} \u2013 the user denied the request {message: \"Api rejected by user\", code: 12} - the website is not trusted signTransaction A method for signing transactions in 0bsNetwork. Example: const txData = { type: 4, data: { amount: { assetId: \"ZBS\", tokens: \"1.567\" }, fee: { assetId: \"ZBS\", tokens: \"0.001\" }, recipient: \"test\" } }; zbsLink.signTransaction(txData).then((data) => { //data \u2013 a line ready for sending to 0bsNetwork's node (server) }).catch((error) => { //Processing errors }); API returns lines, not an object, as in javascript precision is lost in operation with 8-byte integers. A description of supported transaction types is below. In the example, we are signing a transaction for transferring ZBS to the alias test in 0bsnetwork. REPLY {\"version\":2,\"assetId\":\"\", \"amount\":156700000,\"feeAssetId\":\"\",fee:100000, \"recipient\":\"recipient\",\"attachment\":\"\", \"timestamp\":1548770230589,\"senderPublicKey\":\"public key\",\"proofs\":[\"signature\"],\"type\":4} ERRORS {message: \"User denied message\", code: 10} \u2013 The user denied the request. {message: \"Api rejected by user\", code: 12} \u2013 The website is not trusted. {message: \"Invalid data\", data: \"Reason\", code: 9} \u2013 invalid/incomplete request data. signAndPublishTransaction This is similar to \" signTransaction\" , but it also broadcasts a transaction to the blockchain. Example: const txData = { type: 4, data: { amount: { assetId: \"ZBS\", tokens: \"1.567\" }, fee: { assetId: \"ZBS\", tokens: \"0.001\" }, recipient: \"test\" } }; zbsLink.signAndPublishTransaction(txData).then((data) => { //data - a line ready for sending to 0bsNetwork's node (server) }).catch((error) => { //processing errors }); REPLY A reply from 0bsNetwork returns as a line containing the entire past transaction. ERRORS Same as signTransaction {message: \"Filed request\", data: \"Error description\", code: 15} \u2013 a request was signed but not broadcasted signTransactionPackage A package transaction signature. Sometimes several transactions need to be simultaneously signed, and for users' convenience, up to seven transactions at ones could be signed. Only certain types of transactions are permitted: 3 \u2013 token issue 4 \u2013 token transfer 5 \u2013 token re-issue 6 \u2013 token burning 10 \u2013 creating an alias for an address in 0bsNetwork 11 \u2013 mass transfer 12 - DataTransaction Example: const name = \"For Test\"; const tx = [{ type: 4, data: { amount: { assetId: \"ZBS\", tokens: \"1.567\" }, fee: { assetId: \"ZBS\", tokens: \"0.001\" }, recipient: \"test\" }},{ type: 4, data: { amount: { assetId: \"ZBS\", tokens: \"0.51\" }, fee: { assetId: \"ZBS\", tokens: \"0.001\" }, recipient: \"merry\" } }]; zbsLink.signTransactionPackage(tx, name) Sign two transaction: Transfer 1.567 ZBS to the alias test Transfer 0.1 ZBS to the alias merry REPLY A unit of two lines \u2013 transactions that are signed and ready to be broadcasted. ERRORS Same as in \" signTransaction \" Every user of 0bsNetwork has a state (balances, assets, data, scripts), and every past transactions changes these data. \\ In 0bsLink API it is different from NODE REST API . signTransaction , signAndPublishTransaction accept transactions as follows { type: number //transaction type, data: { ... //transaction data } } Legend keys optional field, data are automatically supplied from zbsLink. \\ [x,y] \u2013 length limit from x to y. \\ [,x] \u2013 length limit to x. \\ [y,] \u2013 length limit from y. \\ [x-y] \u2013 number from x to y. x/y - x or y. (JLM) - JAVA LONG MAX = 9 223 372 036 854 775 807 \\ MoneyLike - price MoneyLike could look as: { tokens: 1, assetId: \"ZBS\" } { coins: 100000000, assetId: \"ZBS\" } ; In both messages, the same price of 1 ZBS is indicated. You can easily convert coins into tokens and back, if you know in what asset the price is indicated and you have received its precision tokens = coins / (10 ** precision) \\ If the field contains other types than MoneyLike, for instance, string/MoneyLike , the sum is indicated as a number in coins . Type 3 ISSUE \u2013 token issue name [4, 16] string \u2013 token name, description [0, 1000] string \u2013 token description, quantity [0 - (JLM)] number/string - quantity, precision [0 - 8] number - precision, reissuable true|false \u2013 reissuble, fee MoneyLike -fee *script string \u2013 asset script *senderPublicKey string \u2013 sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 3, data: { \"name\": \"Best Token\", \"description\": \"Greate token\", \"quantity\": 1000000, \"precision\": 2, \"reissuable\": true, fee: { \"tokens\": \"1\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've created my asset!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, we are issuing a new asset in the quantity of 1,000,000, and your balance will show 10,000.00 Best Token \u0422ype 4 TRANSFER \u2013 asset transfer amount MoneyLike - amount, recipient string \u2013 recipient's address or alias attachment [,140 bytes \u0432 base58] string \u2013 additional info fee MoneyLike - fee *senderPublicKey string \u2013 sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 4, data: { amount: { tokens: \"3.3333333\", assetId: \"ZBS\" }, fee: { tokens: \"0.001\", assetId: \"ZBS\"}, recipient: \"merry\" } }).then((tx) => { console.log(\"Hurray! I've been able to send ZBS!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); \u0422ype 5 REISSUE \u2013 token reissue assetId string - \"asset ID\", quantity [0 - (JLM)] number/string/MoneyLike - quantity, reissuable false \u2013 deny reissue fee MoneyLike -fee *senderPublicKey string \u2013 sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 5, data: { \"quantity\": 1000, \"assetId\": \"8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS\", \"reissuable\": true, fee: { \"tokens\": \"1\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've reissued my asset!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, we are re-issuing a new asset in the quantity of 1,000,000, and your balance will show 10,000.00 Best Token \u0422ype 6 BURN \u2013 burning tokens assetId string \u2013 asset ID, amount [0 - (JLM)] number/string/MoneyLike - quantity, fee MoneyLike -fee *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 6, data: { amount: 1000, assetId: \"8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS\", fee: { \"tokens\": \"0.001\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've burned unneeded tokens!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, 1,000 coins are burned . \u0422ype 8 LEASE - Leasing recipient string \u2013 recipient's address or alias, amount [0 - (JLM)] number/string/MoneyLike - quantity, fee MoneyLike -fee *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 8, data: { \"amount\": 1000, \"recipient\": \"merry\", fee: { \"tokens\": \"0.001\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've been able to lease tokens!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, 0.00001000 ZBS is leased. \u0422ype 9 LEASE CANCEL \u2013 cancel leasing leaseId string \u2013 leasing transaction ID, fee MoneyLike -fee *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 9, data: { leaseId: \"6frvwF8uicAfyEfTfyC2sXqBJH7V5C8he5K4YH3BkNiS\", fee: { \"tokens\": \"0.001\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've cancelled leasing!!!\"); }).catch((error) => { console.error(\"Something went wrong \", error); }); In case of a success, the leasing transaction is cancelled. \u0422ype 10 CREATE ALIAS \u2013 creating an alias for an address alias [4, 30] string - alias fee MoneyLike -fee *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 10, data: { alias: \"testAlias\", fee: { \"tokens\": \"0.001\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! Now I have an alias!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, an alias (another name) is created. \u0422ype 11 MASS TRANSFER - a mass transfer of an asset totalAmount moneyLike \u2013 total to be sent // instead of calculating the amount you may insert { assetId: \"ID of the asset to be sent\", coins: 0}, transfers a mass of objects { recipient : string - address/alias, amount: number/string/moneyLike } fee MoneyLike -fee attachment [,140 bytes \u0432 base58] string \u2013 additional info *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 11, data: { totalAmount: { assetId: \"ZBS\", coins: 0}, transfers: [ { recipient: \"alias1\", amount: \"200000\" }, { recipient: \"alias2\", amount: \"200000\" }, ], fee: { \"tokens\": \"0.002\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've sent hi to my friends!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, 0.002 ZBS will be sent to alias1 and alias2. \u0422ype 12 DATA TRANSACTION - saving data data mass of objects type \"binary\"/string/\"integer\"/\"boolean\" - type, key string \u2013 field name value /string/string/number/boolean depends on the type fee MoneyLike - fee *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms Field: zbsLink.signAndPublishTransaction({ type: 12, data: { data: [ { key: \"string\", value: \"testVal\", type: \"string\" }, { key: \"binary\", value: \"base64:AbCd\", type: \"binary\" }, { key: \"integer\", value: 20, type: \"integer\" }, { key: \"boolean\", value: false, type: \"boolean\" }, ], fee: { \"tokens\": \"0.01\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've saved data!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, new data will be stored in the state. \u0422ype 13 SET SCRIPT \u2013 scrypting an account script string - script fee MoneyLike -fee *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms For cancelling a script the field script has to be \"\". Script development on RIDE Example: zbsLink.signAndPublishTransaction({ type: 13, data: { script: \"\", fee: { \"tokens\": \"0.04\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've cancelled a script!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, the script will be removed from the account. Example 2: zbsLink.signAndPublishTransaction({ type: 13, data: { script: \"base64:AQa3b8tH\", fee: { \"tokens\": \"0.01\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've added a script!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, a new script will be added to the account, allowing any transactions without a signature (be careful!). \u0422ype 14 Sponsored Fee Transaction - Sponsorship minSponsoredAssetFee MoneyLike \u2013 fee price in the asset. fee MoneyLike - fee *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms Example: zbsLink.signAndPublishTransaction({ type: 14, data: { minSponsoredAssetFee: { assetId: \"6frvwF8uicAfyEfTfyC2sXqBJH7V5C8he5K4YH3BkNiS\", tokens: 0.1 }, fee: { \"tokens\": \"1\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've become a sponsor!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, a transfer fee can be paid in the asset. \u0422ype 15 SET ASSET SCRIPT \u2013 setting a script to an asset assetId string \u2013 asset ID script string - [script] fee MoneyLike -fee *senderPublicKey string - sender's public key in base58 *timestamp number/string \u2013 time in ms It's now impossible to cancel a script, you can only add a new script. Script development on RIDE Example: zbsLink.signAndPublishTransaction({ type: 15, data: { assetId: \"\", script: \"base64:AQa3b8tH\", fee: { \"tokens\": \"0.01\", \"assetId\": \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I have reset a script to the asset!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); In case of a success, the asset's script will be reset. signOrder 0bsLink's method for signing an order to the matcher. As input, it accepts an object similar to a transaction like this: { type: 1002, data: { ...data } } amount MoneyLike - amount price MoneyLike - price orderType 'sell'/'buy' \u2013 order type matcherFee MoneyLike - fee (0.003 ZBS minimum), matcherPublicKey string - the public key of the exchange service expiration string/number \u2013 the order's expiration time *timestamp string/number - current time *senderPublicKey string - public key in base58 Example: zbsLink.signOrder({ type: 1002, data: { matcherPublicKey: \"7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy\", orderType: \"sell\", expiration: Date.now() + 100000, amount: { tokens: \"100\", assetId: \"ZBS\" }, price: { tokens: \"0.01\", assetId: \"8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS\" }, matcherFee: { tokens: \"0.03\", assetId: \"ZBS\" } } }).then((tx) => { console.log(\"Hurray! I've signed an order!!!\"); }).catch((error) => { console.error(\"Something went wrong\", error); }); REPLY: A line with data for sending to the matcher. ERRORS: { message: \"User denied message\", code: 10 } \u2013 the user rejected the request { message: \"Api rejected by user\", code: 12 } \u2013 The website is not trusted { message: \"Invalid data\", data: \"Reason\", code: 9 } - invalid/incomplete request data signAndPublishOrder 0bsLink's method for creating an order to the matcher is identical to signOrder , but it also tries to send data to the matcher. REPLY: the matcher's reply line about successful creation of an order. ERRORS: Same as for signOrder {message: \"Filed request\", data: \"Error description\", code: 15} \u2013 a request has been signed, but not sent to the matcher signCancelOrder 0bsLink's method for signing cancellation of an order to the matcher. As input, it accepts an object similar to a transaction like this: { type: 1003, data: { ...data } } id string \u2013 order ID *senderPublicKey - string - sender's public key in base58 Example: zbsLink.signCancelOrder({ type: 1003, data: { id: '31EeVpTAronk95TjCHdyaveDukde4nDr9BfFpvhZ3Sap' } }); REPLY: A data line for sending to the matcher. ERRORS: { message: \"User denied message\", code: 10 } \u2013 the user rejected the request { message: \"Api rejected by user\", code: 12 } \u2013 The website is not trusted { message: \"Invalid data\", data: \"Reason\", code: 9 } - invalid/incomplete request data signAndPublishCancelOrder 0bsLink's method for cancelling an order to the matcher. It works identically to signCancelOrder , but also tries to send data to the matcher. Example: zbsLink.signAndPublishCancelOrder({ type: 1003, data: { id: '31EeVpTAronk95TjCHdyaveDukde4nDr9BfFpvhZ3Sap' } }).then(() => { console.log('Hurray! I've cancelled an order'); }).catch((error) => { console.error(\"Something went wrong\", error); }) REPLY: Data that came from the matcher ERRORS: Same as for signCancelOrder {message: \"Filed request\", data: \"Error description\", code: 15} \u2013 a request has been signed, but not sent to the matcher signRequest 0bsLink's method for signing typified data, for signing requests on various services. As input, it accepts an object similar to a transaction like this: { type: number, data: { ...data } } Currently, the method supports the following types: 1001 \u2013 signing data for a request to the matcher for your orders timestamp number/string *senderPublicKey string public key in base58 Example: zbsLink.signRequest({ type: 1001, data: { timestamp: 234234242423423 } }); REPLY: a line with a signature in base58. ERRORS: { message: \"User denied message\", code: 10 } \u2013 the user rejected the request { message: \"Api rejected by user\", code: 12 } \u2013 The website is not trusted { message: \"Invalid data\", data: \"Reason\", code: 9 } - invalid/incomplete request data 1004 \u2013 signing data for a request to Coinomat timestamp number/string Request: zbsLink.signRequest({ type: 1004, data: { timestamp: 234234242423423 } }); REPLY: a line with a signature in base58. ERRORS: { message: \"User denied message\", code: 10 } \u2013 the user rejected the request { message: \"Api rejected by user\", code: 12 } \u2013 The website is not trusted { message: \"Invalid data\", data: \"Reason\", code: 9 } - invalid/incomplete request data","title":"Description of methods"},{"location":"nodeapi/","text":"Full Node API The full node exposes an API that allows you to manage the node, get information about its status, get information about the blockchain, and interact with the blockchain. The node comes with its own API documentation which goes some way to explain the features and functions and that can be found on port 7431 on your own node, or you can use our public node API here; https://node1.testnet-0bsnetwork.com To enable the API on your own node, you need to enable it, set its API key, and ensure its listening and exposed on the firewall. Within your nodes configuration file, find the rest-api section and set; enable = yes bind-address = Your IP or 0.0.0.0 to listen on all IPs double check the port its 7431 for testnet and 7441 for mainnet and open up that port on your firewall (ufw allow 7431) Initially set api-key-hash to some gibberish to protect your API, and we can set it properly in the next step. rest-api { enable = yes bind-address = \"127.0.0.1\" port = 7431 api-key-hash = \"86GJVSoboK12zXHYJFzoucAKaFS1yyXA2NztWSt9tGiX\" } Once you restart your node, you should be able to access the swagger interface at http://yournode:7431 Now we need to setup the API key, and the API conveniently has a feature to do that, open up the 'utils' section on the API page, and find; utils/hash/secure Enter your desired API key and hit 'try it out' and it should give you a hash in response. Paste that into the api-key-hash in your config file and restart your node again, you can now use the API key in API calls that require it. This API key gives you access to features on your node using the nodes wallet, for example, you can have the node sign a transaction Signing Transactions on the Node You can send a transaction to your node to sign, and it will be signed using the private key of the nodes wallet (Ensure the nodes wallet has funds... You can get its address from the nodes API /addresses endpoint) The steps to do this are as below. Note: Its not possible to sign transactions on our public nodes as the node does these oprations using its own private key Obtain the correct JSON transaction format from Transactions POST the json to the /transactions/sign endpoint (Including your API key in the header X-API-Key) The node returns a signed transaction POST the signed transaction to the nodes /transactions/broadcast endpoint Below is an example of the transactions/sign endpoint curl -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' --header 'X-API-Key: myapikey' -d '{ \\ \"senderPublicKey\":\"4c5K4kGeRdrnSYZ9wngQKSozikVgfxmDEuViirsyUHwd\", \\ \"amount\":110000000 \\ fee\":500000, \\ \"type\":4, \\ \"version\":2, \\ \"attachment\":\"\", \\ \"sender\":\"3MyT3r1S8xvKtiKnLgVNNiSAiQdnMbffBQy\", \\ \"feeAssetId\":null, \\ \"proofs\":[\"2KFbYWi9BJwDG9dbiJQzC9qJPpu4Ug8Ybs331fQbX9FAkEpEtrj9DKvwNG7cb2m98DV6NCoKH4MBVtGGFsnQWPV6\"], \\ \"assetId\":null, // If we are sending an asset, null for ZBS \\ \"recipient\":\"3MqEisFsWdhvDMAKBwZzZv4niVsfJJtxcaw\", \\ \"feeAsset\":null \\ }' 'https://node1.testnet-0bsnetwork.com/transactions/sign' Of course this is not ideal for many situations, and you need to sign the transaction on the client side, and only use the node to broadcast the transaction. Our libraries help with this, or check out Transactions For more details on manually signing transactions. Matcher API Matcher also has an API to create orders, and get orderbook information. The documentation for this is hosted by the matcher at; https://matcher.testnet-0bsnetwork.com","title":"Full Node REST API"},{"location":"nodeapi/#full-node-api","text":"The full node exposes an API that allows you to manage the node, get information about its status, get information about the blockchain, and interact with the blockchain. The node comes with its own API documentation which goes some way to explain the features and functions and that can be found on port 7431 on your own node, or you can use our public node API here; https://node1.testnet-0bsnetwork.com To enable the API on your own node, you need to enable it, set its API key, and ensure its listening and exposed on the firewall. Within your nodes configuration file, find the rest-api section and set; enable = yes bind-address = Your IP or 0.0.0.0 to listen on all IPs double check the port its 7431 for testnet and 7441 for mainnet and open up that port on your firewall (ufw allow 7431) Initially set api-key-hash to some gibberish to protect your API, and we can set it properly in the next step. rest-api { enable = yes bind-address = \"127.0.0.1\" port = 7431 api-key-hash = \"86GJVSoboK12zXHYJFzoucAKaFS1yyXA2NztWSt9tGiX\" } Once you restart your node, you should be able to access the swagger interface at http://yournode:7431 Now we need to setup the API key, and the API conveniently has a feature to do that, open up the 'utils' section on the API page, and find; utils/hash/secure Enter your desired API key and hit 'try it out' and it should give you a hash in response. Paste that into the api-key-hash in your config file and restart your node again, you can now use the API key in API calls that require it. This API key gives you access to features on your node using the nodes wallet, for example, you can have the node sign a transaction","title":"Full Node API"},{"location":"nodeapi/#signing-transactions-on-the-node","text":"You can send a transaction to your node to sign, and it will be signed using the private key of the nodes wallet (Ensure the nodes wallet has funds... You can get its address from the nodes API /addresses endpoint) The steps to do this are as below. Note: Its not possible to sign transactions on our public nodes as the node does these oprations using its own private key Obtain the correct JSON transaction format from Transactions POST the json to the /transactions/sign endpoint (Including your API key in the header X-API-Key) The node returns a signed transaction POST the signed transaction to the nodes /transactions/broadcast endpoint Below is an example of the transactions/sign endpoint curl -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' --header 'X-API-Key: myapikey' -d '{ \\ \"senderPublicKey\":\"4c5K4kGeRdrnSYZ9wngQKSozikVgfxmDEuViirsyUHwd\", \\ \"amount\":110000000 \\ fee\":500000, \\ \"type\":4, \\ \"version\":2, \\ \"attachment\":\"\", \\ \"sender\":\"3MyT3r1S8xvKtiKnLgVNNiSAiQdnMbffBQy\", \\ \"feeAssetId\":null, \\ \"proofs\":[\"2KFbYWi9BJwDG9dbiJQzC9qJPpu4Ug8Ybs331fQbX9FAkEpEtrj9DKvwNG7cb2m98DV6NCoKH4MBVtGGFsnQWPV6\"], \\ \"assetId\":null, // If we are sending an asset, null for ZBS \\ \"recipient\":\"3MqEisFsWdhvDMAKBwZzZv4niVsfJJtxcaw\", \\ \"feeAsset\":null \\ }' 'https://node1.testnet-0bsnetwork.com/transactions/sign' Of course this is not ideal for many situations, and you need to sign the transaction on the client side, and only use the node to broadcast the transaction. Our libraries help with this, or check out Transactions For more details on manually signing transactions.","title":"Signing Transactions on the Node"},{"location":"nodeapi/#matcher-api","text":"Matcher also has an API to create orders, and get orderbook information. The documentation for this is hosted by the matcher at; https://matcher.testnet-0bsnetwork.com","title":"Matcher API"},{"location":"python/","text":"Python Library - zbsPy ZbsPy is an object-oriented Python interface to the 0bsNetwork blockchain platform. Getting Started You can install ZbsPy using: pip install zbspy Documentation The library utilizes classes to represent various Zbs data structures: zbspy.Address zbspy.Asset zbspy.AssetPair zbspy.Order Code Example import zbspy as pw myAddress = pw.Address(privateKey='CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S') otherAddress = pw.Address('3PNTcNiUzppQXDL9RZrK3BcftbujiFqrAfM') myAddress.sendZbs(otherAddress, 10000000) myToken = myAddress.issueAsset('Token1', 'My Token', 1000, 0) while not myToken.status(): pass myAddress.sendAsset(otherAddress, myToken, 50) Address Class zbspy.Address(address, publicKey, privateKey, seed) Creates a new Address object attributes: address publicKey privateKey seed methods: balance(assetId='', confirmations=0) returns balance of Zbs or other assets assets() returns a list of assets owned by the address issueAsset(name, description, quantity, decimals=0, reissuable=False, txFee=DEFAULT_ASSET_FEE, timestamp=0) issue a new asset reissueAsset(Asset, quantity, reissuable=False, txFee=DEFAULT_ASSET_FEE, timestamp=0) reissue an asset burnAsset(Asset, quantity, txFee=DEFAULT_ASSET_FEE, timestamp=0) burn the specified quantity of an asset sendZbs(recipient, amount, attachment='', txFee=DEFAULT_TX_FEE, timestamp=0) send specified amount of Zbs to recipient massTransferZbs(transfers, attachment='', timestamp=0) sending Zbs tokens via a mass transfer sendAsset(recipient, asset, amount, attachment='', txFee=DEFAULT_TX_FEE, timestamp=0) send specified amount of an asset to recipient massTransferZbs(self, transfers, attachment='', timestamp=0) sending an asset via mass transfer cancelOrder(assetPair, order) cancel an order buy(assetPair, amount price, maxLifetime=30*86400, matcherFee=DEFAULT_MATCHER_FEE, timestamp=0) post a buy order tradableBalance(assetPair) get tradable balance for the specified asset pair sell(assetPair, amount, price, maxLifetime=30*86400, matcherFee=DEFAULT_MATCHER_FEE, timestamp=0) post a sell order lease(recipient, amount, txFee=DEFAULT_LEASE_FEE, timestamp=0) post a lease transaction leaseCancel(leaseId, txFee=DEFAULT_LEASE_FEE, timestamp=0) cancel a lease getOrderHistory(assetPair) get order history for the specified asset pair cancelOpenOrders(assetPair) cancel all open orders for the specified asset pair deleteOrderHistory(assetPair) delete order history for the specified asset pair createAlias(alias, txFee=DEFAULT_ALIAS_FEE, timestamp=0) create alias sponsorAsset(assetId, minimalFeeInAssets, txFee=zbspy.DEFAULT_SPONSOR_FEE, timestamp=0) sponsoring assets setScript(script, txFee=zbspy.DEFAULT_SCRIPT_FEE, timestamp=0) sets a script for this address dataTransaction(data, timestamp=0) sets data for the account. data should be a json array with entries including type (bool, binary, int, string), key and value setScript(scriptSource, txFee=zbspy.DEFAULT_SCRIPT_FEE, timestamp=0) issue a smart asset setAssetScript(asset, scriptSource, txFee=zbspy.DEFAULT_ASSET_SCRIPT_FEE, timestamp=0) set a new script for a smart asset Asset Class zbspy.Asset(assetId) Creates a new Asset object attributes: status assetId issuer name description quantity decimals = 0 reissuable = False methods: status() returns 'Issued' if the asset exists AssetPair Class zbspy.AssetPair(asset1, asset2) Creates a new AssetPair object with 2 Asset objects attributes: asset1 asset2 methods: orderbook() get order book ticker() get ticker with 24h ohlcv data last() get traded price open() get 24h open price high() get 24h high price low() get 24h low price close() get 24h close price (same as last()) vwap() get 24h vwap price volume() get 24h volume priceVolume() get 24h price volume trades(n) get the last n trades trades(from, to) get the trades in from/to interval candles(timeframe, n) get the last n candles in the specified timeframe candles(timeframe, from, to) get the candles in from/to interval in the specified timeframe Order Class zbspy.Order(orderId, assetPair, address='') Creates a new Order object attributes: status orderId assetPair address matcher matcherPublicKey methods: status() returns current order status cancel() cancel the order Other functions zbspy.setNode(node, chain, chain_id) set node URL ('http://ip-address:port') and chain (either 'mainnet' or 'testnet', or any other chain, if you also define the chain id) zbspy.setChain(chain, chain_id) set chain (either 'mainnet' or 'testnet', or any other chain if you also supply the chain id) zbspy.setOffline() switch to offline mode; sign tx locally without broadcasting to network zbspy.setOnline() switch to online mode; sign tx locally a broadcast to network zbspy.validateAddress(address) checks if the provided address is a valid Zbs address zbspy.setMatcher(node) set matcher URL ('http://ip-address:port') zbspy.setDatafeed(node) set datafeed URL ('http://ip-address:port') zbspy.height() get blockchain height zbspy.lastblock() get last block zbspy.block(n) get block at specified height zbspy.tx(id) get transaction details zbspy.symbols() get list of symbol-asset mapping zbspy.markets() get all traded markets with tickers zbspy.{SYMBOL_NAME} get predefined asset for the specified symbol (zbspy.ZBS, zbspy.BTC, zbspy.USD,...) Default Fees The fees for zbs/asset transfers, asset issue/reissue/burn and matcher transactions are set by default as follows: * DEFAULT_TX_FEE = 100000 * DEFAULT_ASSET_FEE = 100000000 * DEFAULT_MATCHER_FEE = 1000000 * DEFAULT_LEASE_FEE = 100000 * DEFAULT_ALIAS_FEE = 100000 * DEFAULT_SPONSOR_FEE = 100000000 * DEFAULT_SCRIPT_FEE = 100000 More Examples Playing with addresses: import zbspy as pw # generate a new address myAddress = pw.Address() # set an address with an address myAddress = pw.Address('3P6WfA4qYtkgwVAsWiiB6yaea2X8zyXncJh') # get an existing address from seed myAddress = pw.Address(seed='seven wrist bargain hope pattern banner plastic maple student chaos grit next space visa answer') # get an existing address from privateKey myAddress = pw.Address(privateKey='CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S') # get an existing address from a publicKey address = pw.Address(publicKey=\u201cEYNuSmW4Adtcc6AMCZyxkiHMPmF2BZ2XxvjpBip3UFZL\u201d) # get an address from a seed with a different nonce (This is especially useful for accessing addresses generated by nodes) myAddress = pw.Address(seed='seven wrist bargain hope pattern banner plastic maple student chaos grit next space visa answer', nonce=1) Balances: import zbspy as pw myAddress = pw.Address('3P6WfA4qYtkgwVAsWiiB6yaea2X8zyXncJh') # get Zbs balance print(\"Your balance is %18d\" % myAddress.balance()) # get Zbs balance after 20 confirmations print(\"Your balance is %18d\" % myAddress.balance(confirmations = 20)) # get an asset balance print(\"Your asset balance is %18d\" % myAddress.balance('DHgwrRvVyqJsepd32YbBqUeDH4GJ1N984X8QoekjgH8J')) Zbs and asset transfers: import zbspy as pw myAddress = pw.Address(privateKey='CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S') # send Zbs to another address myAddress.sendZbs(recipient = pw.Address('3PNTcNiUzppQXDL9RZrK3BcftbujiFqrAfM'), amount = 100000000) # send asset to another address myToken = pw.Asset('4ZzED8WJXsvuo2MEm2BmZ87Azw8Sx7TVC6ufSUA5LyTV') myAddress.sendAsset(recipient = pw.Address('3PNTcNiUzppQXDL9RZrK3BcftbujiFqrAfM'), asset = myToken, amount = 1000) Issuing an asset: import zbspy as pw myToken = myAddress.issueAsset( name = \"MyToken\", description = \"This is my first token\", quantity = 1000000, decimals = 2 ) Create an alias: import zbspy as pw pw.setNode(node = 'http://127.0.0.1:7431', chain = 'testnet') myAddress = pw.Address(privateKey='CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S') myAddress.createAlias(\"MYALIAS1\") Mass payment: import zbspy as pw recipients = ['3PBbp6bg2YEnHfdJtYM7jzzXYQeb7sx5oFg', '3P4A27aCd3skNja46pcgrLYEnK36TkSzgUp', '3P81U3ujotNUwZMWALdcJQLzBVbrAuUQMfs', '3PGcKEMwQcEbmeL8Jhe9nZQRBNCNdcHCoZP', '3PKjtzZ4FhKrJUikbQ1hRk5xbwVKDyTyvkn'] myAddress = pw.Address(privateKey = \"CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S\") for address in recipients: myAddress.sendZbs(pw.Address(address), 1000000) Mass transfer of Zbs (feature 11) import zbspy as pw transfers = [ { 'recipient': '3N1xca2DY8AEwqRDAJpzUgY99eq8J9h4rB3', 'amount': 1 }, { 'recipient': '3N3YWbQ27NnK7tek6ASFh38Bj93guLxxSi1', 'amount': 2 }, { 'recipient': '3MwiB5UkWxt4X1qJ8DQpP2LpM3m48V1z5rC', 'amount': 3 } ] address = pw.Address(privateKey = \"CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S\") address.massTransferZbs(transfers) Mass transfer of Assets (feature 11) import zbspy as pw transfers = [ { 'recipient': '3N1xca2DY8AEwqRDAJpzUgY99eq8J9h4rB3', 'amount': 1 }, { 'recipient': '3N3YWbQ27NnK7tek6ASFh38Bj93guLxxSi1', 'amount': 2 }, { 'recipient': '3MwiB5UkWxt4X1qJ8DQpP2LpM3m48V1z5rC', 'amount': 3 } ] address = pw.Address(privateKey = \"CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S\") address.massTransferAssets(transfers, pw.Asset('9DtBNdyBCyViLZHptyF1HbQk73F6s7nQ5dXhNHubtBhd')) Data Transaction: import zbspy as py myAddress = py.Address(privateKey='CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S') data = [{ 'type':'string', 'key': 'test', 'value':'testval' }] myAddress.dataTransaction(data) Token airdrop: import zbspy as pw myAddress = pw.Address(privateKey = '`') myToken = pw.Asset('4ZzED8WJXsvuo2MEm2BmZ87Azw8Sx7TVC6ufSUA5LyTV') amount = 1000 with open('recipients.txt') as f: lines = f.readlines() for address in lines: myAddress.sendAsset(pw.Address(address.strip()), myToken, amount) Add a script to an account: import zbspy as pw import base64 pw.setNode(node='<node>', chain='testnet') script = 'match tx { \\n' + \\ ' case _ => true\\n' + \\ '}' address = pw.Address(privateKey = \"<private key>\") tx = address.setScript(script, txFee=1000000) Issue a Smart Asset imort zbspy as pw import base64 pw.setNode(node='<node>', chain='testnet') script = 'match tx { \\n' + \\ ' case _ => true\\n' + \\ '}' address = pw.Address(privateKey = '<private key>') tx = address.issueSmartAsset('smartTestAsset', 'an asset for testingsmart assets', 1000, script, 2) Set a new script for a Smart Asset import zbspy as pw import base64 pw.setNode(node='<node>', chain='testnet') script = 'match tx { \\n' + \\ ' case _ => true\\n' + \\ '}' address = pw.Address(privateKey = '<private key>') tx = address.setAssetScript(pw.Asset('<asset id>'), script) Playing with Zbs Matcher node (DEX): import zbspy as pw # set Matcher node to use pw.setMatcher(node = 'http://127.0.0.1:7442') # post a buy order BTC = pw.Asset('4ZzED8WJXsvuo2MEm2BmZ87Azw8Sx7TVC6ufSUA5LyTV') USD = pw.Asset('6wuo2hTaDyPQVceETj1fc5p4WoMVCGMYNASN8ym4BGiL') BTC_USD = pw.AssetPair(BTC, USD) myOrder = myAddress.buy(assetPair = BTC_USD, amount = 15e8, price = 95075) # post a sell order WCT = pw.Asset('6wuo2hTaDyPQVceETj1fc5p4WoMVCGMYNASN8ym4BGiL') Incent = pw.Asset('FLbGXzrpqkvucZqsHDcNxePTkh2ChmEi4GdBfDRRJVof') WCT_Incent = pw.AssetPair(WCT, Incent) myOrder = myAddress.sell(assetPair = WCT_Incent, amount = 100e8, price = 25e8) # post a buy order using Zbs as price asset BTC = pw.Asset('4ZzED8WJXsvuo2MEm2BmZ87Azw8Sx7TVC6ufSUA5LyTV') BTC_ZBS = pw.AssetPair(BTC, pw.ZBS) myOrder = myAddress.buy(assetPair = BTC_ZBS, amount = 1e8, price = 50e8) # cancel an order myOrder.cancel() # or myAddress.cancelOrder(assetPair, myOrder) Getting Market Data from Zbs Data Feed (WDF): import zbspy as pw # set the asset pair ZBS_BTC = pw.AssetPair(pw.ZBS, pw.BTC) # get last price and volume print(\"%s %s\" % (ZBS_BTC.last(), ZBS_BTC.volume())) # get ticker ticker = ZBS_BTC.ticker() print(ticker['24h_open']) print(ticker['24h_vwap']) # get last 10 trades trades = ZBS_BTC.trades(10) for t in trades: print(\"%s %s %s %s\" % (t['buyer'], t['seller'], t['price'], t['amount'])) # get last 10 daily OHLCV candles ohlcv = ZBS_BTC.candles(1440, 10) for t in ohlcv: print(\"%s %s %s %s %s\" % (t['open'], t['high'], t['low'], t['close'], t['volume'])) LPOS import zbspy as pw # connect to a local testnet node pw.setNode(node = 'http://127.0.0.1:7431', chain = 'testnet') myAddress = pw.Address(privateKey = 'CsBpQpNE3Z1THNMS9vJPaXqYwN9Hgmhd9AsAPrM3tiuJ') minerAddress = pw.Address('3NBThmVJmcexzJ9itP9KiiC2K6qnGQwpqMq') # lease 1000 Zbs to minerAddress leaseId = myAddress.lease(minerAddress, 100000000000) # revoke the lease myAddress.leaseCancel(leaseId) Using ZbsPy in a Python shell Check an address balance: >>> import zbspy as pw >>> pw.Address('3P31zvGdh6ai6JK6zZ18TjYzJsa1B83YPoj') address = 3P31zvGdh6ai6JK6zZ18TjYzJsa1B83YPoj publicKey = privateKey = seed = balances: Zbs = 1186077288304570 BDMRyZsmDZpgKhdM7fUTknKcUbVVkDpMcqEj31PUzjMy (Tokes) = 43570656915 RRBqh2XxcwAdLYEdSickM589Vb4RCemBCPH5mJaWhU9 (Ripto Bux) = 4938300000000 4rmhfoscYcjz1imNDvtz45doouvrQqDpbX7xdfLB4guF (incentCoffee) = 7 Ftim86CXM6hANxArJXZs2Fq7XLs3nJvgBzzEwQWwQn6N (Zbs) = 2117290600000000 E4ip4jzTc4PCvebYn1818T4LNoYBVL3Y4Y4dMPatGwa9 (BitCoin) = 500000000000 FLbGXzrpqkvucZqsHDcNxePTkh2ChmEi4GdBfDRRJVof (Incent) = 12302659925430 GQr2fpkfmWjMaZCbqMxefbiwgvpcNgYdev7xpuX6xqcE (KISS) = 1000 DxG3PLganyNzajHGzvWLjc4P3T2CpkBGxY4J9eJAAUPw (UltraCoin) = 200000000000000 4eWBPyY4XNPsFLoQK3iuVUfamqKLDu5o6zQCYyp9d8Ae (LIKE) = 1000 >>> Generate a new address: >>> import zbspy as pw >>> pw.Address() address = 3P6WfA4qYtkgwVAsWiiB6yaea2X8zyXncJh publicKey = EYNuSmW4Adtcc6AMCZyxkiHMPmF2BZ2XxvjpBip3UFZL privateKey = CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S seed = seven wrist bargain hope pattern banner plastic maple student chaos grit next space visa answer balances: Zbs = 0 >>> Check an asset: >>> import zbspy as pw >>> pw.Asset('DHgwrRvVyqJsepd32YbBqUeDH4GJ1N984X8QoekjgH8J') status = Issued assetId = DHgwrRvVyqJsepd32YbBqUeDH4GJ1N984X8QoekjgH8J issuer = 3PPKF2pH4KMYgsDixjrhnWrPycVHr1Ye37V name = ZbsCommunity description = Zbs community token. quantity = 1000000000 decimals = 2 reissuable = False Post an order and check its status: >>> myOrder = myAddress.buy(pw.AssetPair(token1, token2), 1, 25) >>> myOrder status = Accepted id = ARZdYgfXz3ksRMvhnGeLLJnn3CQnz7RCa7U6dVw3zert asset1 = AFzL992FQbhcgSZGKDKAiRWcjtthM55yVCE99hwbHf88 asset2 = 49Aha2RR2eunR3KZFwedfdi7K9v5MLQbLYcmVdp2QkZT sender.address = 3P6WfA4qYtkgwVAsWiiB6yaea2X8zyXncJh sender.publicKey = EYNuSmW4Adtcc6AMCZyxkiHMPmF2BZ2XxvjpBip3UFZL matcher = http://127.0.0.1:7442 Cancel the order >>> myOrder.cancel() >>> myOrder status = Cancelled id = ARZdYgfXz3ksRMvhnGeLLJnn3CQnz7RCa7U6dVw3zert asset1 = AFzL992FQbhcgSZGKDKAiRWcjtthM55yVCE99hwbHf88 asset2 = 49Aha2RR2eunR3KZFwedfdi7K9v5MLQbLYcmVdp2QkZT sender.address = 3P6WfA4qYtkgwVAsWiiB6yaea2X8zyXncJh sender.publicKey = EYNuSmW4Adtcc6AMCZyxkiHMPmF2BZ2XxvjpBip3UFZL matcher = http://127.0.0.1:7442 Offline signing and custom timestamps Offline signing a future transaction: >>> import zbspy as pw >>> pw.setOffline() >>> myAddress=pw.Address(privateKey=\"F2jVbjrKzjUsZ1AQRdnd8MmxFc85NQz5jwvZX4BXswXv\") >>> recipient=pw.Address(\"3P8Ya6Ary5gzwnzbBXDp3xjeNG97JEiPcdA\") # sign a future tx to transfer 100 ZBS to recipient # the tx is valid on Jan 1st, 2020 12:00pm >>> myAddress.sendZbs(recipient, amount=100e8, timestamp=1577880000000) {'api-endpoint': '/assets/broadcast/transfer', 'api-type': 'POST', 'api-data': '{\"fee\": 100000, \"timestamp\": 1577880000000, \"senderPublicKey\": \"27zdzBa1q46RCMamZ8gw2xrTGypZnbzXs5J1Y2HbUmEv\", \"amount\": 10000000000, \"attachment\": \"\", \"recipient\": \"3P8Ya6Ary5gzwnzbBXDp3xjeNG97JEiPcdA\" \"signature\": \"YetPopTJWC4WBPXbneWv9g6YEp6J9g9rquZWjewjdQnFbmaxtXjrRsUu69NZzHebVzUGLrhQiFFoguXJwdUn8BH\"}'} Offline signing time lock/unlock transactions: >>> import zbspy as pw >>> pw.setOffline() >>> myAddress=pw.Address(privateKey=\"F2jVbjrKzjUsZ1AQRdnd8MmxFc85NQz5jwvZX4BXswXv\") # generate a lockbox address >>> lockAddress=pw.Address() # sign the 'lock' tx to send 100e8 to the lockbox (valid on Nov 1st, 2017) >>> myAddress.sendZbs(lockAddress, 100e8, timestamp=1509537600000) {'api-endpoint': '/assets/broadcast/transfer', 'api-type': 'POST', 'api-data': '{\"fee\": 100000, \"timestamp\": 1509537600000, \"senderPublicKey\": \"27zdzBa1q46RCMamZ8gw2xrTGypZnbzXs5J1Y2HbUmEv\", \"amount\": 10000000000, \"attachment\": \"\", \"recipient\": \"3P3UbyQM9W7WzTgjYkLuBrPZZeWsiUtCcpv\", \"signature\": \"5VgT6qWxJwxEyrxFNfsi67QqbyUiGq9Ka7HVzgovRTTDT8nLRyuQv2wBAJQhRiXDkTTV6zsQmHnBkh8keCaFPoNT\"}'} # sign the 'unlock' tx to send funds back to myAddress (valid on Jan 1st, 2020) >>> lockAddress.sendZbs(myAddress, 100e8-200000, txFee=200000, timestamp=1577880000000) {'api-endpoint': '/assets/broadcast/transfer', 'api-type': 'POST', 'api-data': '{\"fee\": 200000, \"timestamp\": 1577880000000, \"senderPublicKey\": \"52XnBGnAVZmw1CHo9aJPiMsVMiTWeNGSNN9aYJ7cDtx4\", \"amount\": 9999800000, \"attachment\": \"\", \"recipient\": \"3P7tfdCaTyYCfg5ojxNahEJDSS4MZ7ybXBY\", \"signature\": \"3beyz1sqKefP96LaXWT3CxdPRW86DAxcj6wgWPyyKq3SgdotVqnKyWXDyeHnBzCq1nC7JA9CChTmo1c1iVAv6C4T\"}'} # delete lockbox address and private key >>> del lockAddress Connecting to a different node or chain ZbsPy supports both mainnet and testnet chains. By default, ZbsPy connects to the mainnet RPC server at https://nodes.0bsnetwork.com. It's possible to specify a different server and chain with the setNode() function import zbspy as pw # connects to a local testnet node pw.setNode(node = 'http://127.0.0.1:7431', chain = 'testnet') # connects to a local mainnet node pw.setNode(node = 'http://127.0.0.1:7441', chain = 'mainnet')","title":"Python Library"},{"location":"python/#python-library-zbspy","text":"ZbsPy is an object-oriented Python interface to the 0bsNetwork blockchain platform.","title":"Python Library - zbsPy"},{"location":"python/#getting-started","text":"You can install ZbsPy using: pip install zbspy","title":"Getting Started"},{"location":"python/#documentation","text":"The library utilizes classes to represent various Zbs data structures: zbspy.Address zbspy.Asset zbspy.AssetPair zbspy.Order","title":"Documentation"},{"location":"python/#code-example","text":"import zbspy as pw myAddress = pw.Address(privateKey='CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S') otherAddress = pw.Address('3PNTcNiUzppQXDL9RZrK3BcftbujiFqrAfM') myAddress.sendZbs(otherAddress, 10000000) myToken = myAddress.issueAsset('Token1', 'My Token', 1000, 0) while not myToken.status(): pass myAddress.sendAsset(otherAddress, myToken, 50)","title":"Code Example"},{"location":"python/#address-class","text":"zbspy.Address(address, publicKey, privateKey, seed) Creates a new Address object","title":"Address Class"},{"location":"python/#attributes","text":"address publicKey privateKey seed","title":"attributes:"},{"location":"python/#methods","text":"balance(assetId='', confirmations=0) returns balance of Zbs or other assets assets() returns a list of assets owned by the address issueAsset(name, description, quantity, decimals=0, reissuable=False, txFee=DEFAULT_ASSET_FEE, timestamp=0) issue a new asset reissueAsset(Asset, quantity, reissuable=False, txFee=DEFAULT_ASSET_FEE, timestamp=0) reissue an asset burnAsset(Asset, quantity, txFee=DEFAULT_ASSET_FEE, timestamp=0) burn the specified quantity of an asset sendZbs(recipient, amount, attachment='', txFee=DEFAULT_TX_FEE, timestamp=0) send specified amount of Zbs to recipient massTransferZbs(transfers, attachment='', timestamp=0) sending Zbs tokens via a mass transfer sendAsset(recipient, asset, amount, attachment='', txFee=DEFAULT_TX_FEE, timestamp=0) send specified amount of an asset to recipient massTransferZbs(self, transfers, attachment='', timestamp=0) sending an asset via mass transfer cancelOrder(assetPair, order) cancel an order buy(assetPair, amount price, maxLifetime=30*86400, matcherFee=DEFAULT_MATCHER_FEE, timestamp=0) post a buy order tradableBalance(assetPair) get tradable balance for the specified asset pair sell(assetPair, amount, price, maxLifetime=30*86400, matcherFee=DEFAULT_MATCHER_FEE, timestamp=0) post a sell order lease(recipient, amount, txFee=DEFAULT_LEASE_FEE, timestamp=0) post a lease transaction leaseCancel(leaseId, txFee=DEFAULT_LEASE_FEE, timestamp=0) cancel a lease getOrderHistory(assetPair) get order history for the specified asset pair cancelOpenOrders(assetPair) cancel all open orders for the specified asset pair deleteOrderHistory(assetPair) delete order history for the specified asset pair createAlias(alias, txFee=DEFAULT_ALIAS_FEE, timestamp=0) create alias sponsorAsset(assetId, minimalFeeInAssets, txFee=zbspy.DEFAULT_SPONSOR_FEE, timestamp=0) sponsoring assets setScript(script, txFee=zbspy.DEFAULT_SCRIPT_FEE, timestamp=0) sets a script for this address dataTransaction(data, timestamp=0) sets data for the account. data should be a json array with entries including type (bool, binary, int, string), key and value setScript(scriptSource, txFee=zbspy.DEFAULT_SCRIPT_FEE, timestamp=0) issue a smart asset setAssetScript(asset, scriptSource, txFee=zbspy.DEFAULT_ASSET_SCRIPT_FEE, timestamp=0) set a new script for a smart asset","title":"methods:"},{"location":"python/#asset-class","text":"zbspy.Asset(assetId) Creates a new Asset object","title":"Asset Class"},{"location":"python/#attributes_1","text":"status assetId issuer name description quantity decimals = 0 reissuable = False","title":"attributes:"},{"location":"python/#methods_1","text":"status() returns 'Issued' if the asset exists","title":"methods:"},{"location":"python/#assetpair-class","text":"zbspy.AssetPair(asset1, asset2) Creates a new AssetPair object with 2 Asset objects","title":"AssetPair Class"},{"location":"python/#attributes_2","text":"asset1 asset2","title":"attributes:"},{"location":"python/#methods_2","text":"orderbook() get order book ticker() get ticker with 24h ohlcv data last() get traded price open() get 24h open price high() get 24h high price low() get 24h low price close() get 24h close price (same as last()) vwap() get 24h vwap price volume() get 24h volume priceVolume() get 24h price volume trades(n) get the last n trades trades(from, to) get the trades in from/to interval candles(timeframe, n) get the last n candles in the specified timeframe candles(timeframe, from, to) get the candles in from/to interval in the specified timeframe","title":"methods:"},{"location":"python/#order-class","text":"zbspy.Order(orderId, assetPair, address='') Creates a new Order object","title":"Order Class"},{"location":"python/#attributes_3","text":"status orderId assetPair address matcher matcherPublicKey","title":"attributes:"},{"location":"python/#methods_3","text":"status() returns current order status cancel() cancel the order","title":"methods:"},{"location":"python/#other-functions","text":"zbspy.setNode(node, chain, chain_id) set node URL ('http://ip-address:port') and chain (either 'mainnet' or 'testnet', or any other chain, if you also define the chain id) zbspy.setChain(chain, chain_id) set chain (either 'mainnet' or 'testnet', or any other chain if you also supply the chain id) zbspy.setOffline() switch to offline mode; sign tx locally without broadcasting to network zbspy.setOnline() switch to online mode; sign tx locally a broadcast to network zbspy.validateAddress(address) checks if the provided address is a valid Zbs address zbspy.setMatcher(node) set matcher URL ('http://ip-address:port') zbspy.setDatafeed(node) set datafeed URL ('http://ip-address:port') zbspy.height() get blockchain height zbspy.lastblock() get last block zbspy.block(n) get block at specified height zbspy.tx(id) get transaction details zbspy.symbols() get list of symbol-asset mapping zbspy.markets() get all traded markets with tickers zbspy.{SYMBOL_NAME} get predefined asset for the specified symbol (zbspy.ZBS, zbspy.BTC, zbspy.USD,...)","title":"Other functions"},{"location":"python/#default-fees","text":"The fees for zbs/asset transfers, asset issue/reissue/burn and matcher transactions are set by default as follows: * DEFAULT_TX_FEE = 100000 * DEFAULT_ASSET_FEE = 100000000 * DEFAULT_MATCHER_FEE = 1000000 * DEFAULT_LEASE_FEE = 100000 * DEFAULT_ALIAS_FEE = 100000 * DEFAULT_SPONSOR_FEE = 100000000 * DEFAULT_SCRIPT_FEE = 100000","title":"Default Fees"},{"location":"python/#more-examples","text":"","title":"More Examples"},{"location":"python/#playing-with-addresses","text":"import zbspy as pw # generate a new address myAddress = pw.Address() # set an address with an address myAddress = pw.Address('3P6WfA4qYtkgwVAsWiiB6yaea2X8zyXncJh') # get an existing address from seed myAddress = pw.Address(seed='seven wrist bargain hope pattern banner plastic maple student chaos grit next space visa answer') # get an existing address from privateKey myAddress = pw.Address(privateKey='CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S') # get an existing address from a publicKey address = pw.Address(publicKey=\u201cEYNuSmW4Adtcc6AMCZyxkiHMPmF2BZ2XxvjpBip3UFZL\u201d) # get an address from a seed with a different nonce (This is especially useful for accessing addresses generated by nodes) myAddress = pw.Address(seed='seven wrist bargain hope pattern banner plastic maple student chaos grit next space visa answer', nonce=1)","title":"Playing with addresses:"},{"location":"python/#balances","text":"import zbspy as pw myAddress = pw.Address('3P6WfA4qYtkgwVAsWiiB6yaea2X8zyXncJh') # get Zbs balance print(\"Your balance is %18d\" % myAddress.balance()) # get Zbs balance after 20 confirmations print(\"Your balance is %18d\" % myAddress.balance(confirmations = 20)) # get an asset balance print(\"Your asset balance is %18d\" % myAddress.balance('DHgwrRvVyqJsepd32YbBqUeDH4GJ1N984X8QoekjgH8J'))","title":"Balances:"},{"location":"python/#zbs-and-asset-transfers","text":"import zbspy as pw myAddress = pw.Address(privateKey='CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S') # send Zbs to another address myAddress.sendZbs(recipient = pw.Address('3PNTcNiUzppQXDL9RZrK3BcftbujiFqrAfM'), amount = 100000000) # send asset to another address myToken = pw.Asset('4ZzED8WJXsvuo2MEm2BmZ87Azw8Sx7TVC6ufSUA5LyTV') myAddress.sendAsset(recipient = pw.Address('3PNTcNiUzppQXDL9RZrK3BcftbujiFqrAfM'), asset = myToken, amount = 1000)","title":"Zbs and asset transfers:"},{"location":"python/#issuing-an-asset","text":"import zbspy as pw myToken = myAddress.issueAsset( name = \"MyToken\", description = \"This is my first token\", quantity = 1000000, decimals = 2 )","title":"Issuing an asset:"},{"location":"python/#create-an-alias","text":"import zbspy as pw pw.setNode(node = 'http://127.0.0.1:7431', chain = 'testnet') myAddress = pw.Address(privateKey='CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S') myAddress.createAlias(\"MYALIAS1\")","title":"Create an alias:"},{"location":"python/#mass-payment","text":"import zbspy as pw recipients = ['3PBbp6bg2YEnHfdJtYM7jzzXYQeb7sx5oFg', '3P4A27aCd3skNja46pcgrLYEnK36TkSzgUp', '3P81U3ujotNUwZMWALdcJQLzBVbrAuUQMfs', '3PGcKEMwQcEbmeL8Jhe9nZQRBNCNdcHCoZP', '3PKjtzZ4FhKrJUikbQ1hRk5xbwVKDyTyvkn'] myAddress = pw.Address(privateKey = \"CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S\") for address in recipients: myAddress.sendZbs(pw.Address(address), 1000000)","title":"Mass payment:"},{"location":"python/#mass-transfer-of-zbs-feature-11","text":"import zbspy as pw transfers = [ { 'recipient': '3N1xca2DY8AEwqRDAJpzUgY99eq8J9h4rB3', 'amount': 1 }, { 'recipient': '3N3YWbQ27NnK7tek6ASFh38Bj93guLxxSi1', 'amount': 2 }, { 'recipient': '3MwiB5UkWxt4X1qJ8DQpP2LpM3m48V1z5rC', 'amount': 3 } ] address = pw.Address(privateKey = \"CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S\") address.massTransferZbs(transfers)","title":"Mass transfer of Zbs (feature 11)"},{"location":"python/#mass-transfer-of-assets-feature-11","text":"import zbspy as pw transfers = [ { 'recipient': '3N1xca2DY8AEwqRDAJpzUgY99eq8J9h4rB3', 'amount': 1 }, { 'recipient': '3N3YWbQ27NnK7tek6ASFh38Bj93guLxxSi1', 'amount': 2 }, { 'recipient': '3MwiB5UkWxt4X1qJ8DQpP2LpM3m48V1z5rC', 'amount': 3 } ] address = pw.Address(privateKey = \"CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S\") address.massTransferAssets(transfers, pw.Asset('9DtBNdyBCyViLZHptyF1HbQk73F6s7nQ5dXhNHubtBhd'))","title":"Mass transfer of Assets (feature 11)"},{"location":"python/#data-transaction","text":"import zbspy as py myAddress = py.Address(privateKey='CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S') data = [{ 'type':'string', 'key': 'test', 'value':'testval' }] myAddress.dataTransaction(data)","title":"Data Transaction:"},{"location":"python/#token-airdrop","text":"import zbspy as pw myAddress = pw.Address(privateKey = '`') myToken = pw.Asset('4ZzED8WJXsvuo2MEm2BmZ87Azw8Sx7TVC6ufSUA5LyTV') amount = 1000 with open('recipients.txt') as f: lines = f.readlines() for address in lines: myAddress.sendAsset(pw.Address(address.strip()), myToken, amount)","title":"Token airdrop:"},{"location":"python/#add-a-script-to-an-account","text":"import zbspy as pw import base64 pw.setNode(node='<node>', chain='testnet') script = 'match tx { \\n' + \\ ' case _ => true\\n' + \\ '}' address = pw.Address(privateKey = \"<private key>\") tx = address.setScript(script, txFee=1000000)","title":"Add a script to an account:"},{"location":"python/#issue-a-smart-asset","text":"imort zbspy as pw import base64 pw.setNode(node='<node>', chain='testnet') script = 'match tx { \\n' + \\ ' case _ => true\\n' + \\ '}' address = pw.Address(privateKey = '<private key>') tx = address.issueSmartAsset('smartTestAsset', 'an asset for testingsmart assets', 1000, script, 2)","title":"Issue a Smart Asset"},{"location":"python/#set-a-new-script-for-a-smart-asset","text":"import zbspy as pw import base64 pw.setNode(node='<node>', chain='testnet') script = 'match tx { \\n' + \\ ' case _ => true\\n' + \\ '}' address = pw.Address(privateKey = '<private key>') tx = address.setAssetScript(pw.Asset('<asset id>'), script)","title":"Set a new script for a Smart Asset"},{"location":"python/#playing-with-zbs-matcher-node-dex","text":"import zbspy as pw # set Matcher node to use pw.setMatcher(node = 'http://127.0.0.1:7442') # post a buy order BTC = pw.Asset('4ZzED8WJXsvuo2MEm2BmZ87Azw8Sx7TVC6ufSUA5LyTV') USD = pw.Asset('6wuo2hTaDyPQVceETj1fc5p4WoMVCGMYNASN8ym4BGiL') BTC_USD = pw.AssetPair(BTC, USD) myOrder = myAddress.buy(assetPair = BTC_USD, amount = 15e8, price = 95075) # post a sell order WCT = pw.Asset('6wuo2hTaDyPQVceETj1fc5p4WoMVCGMYNASN8ym4BGiL') Incent = pw.Asset('FLbGXzrpqkvucZqsHDcNxePTkh2ChmEi4GdBfDRRJVof') WCT_Incent = pw.AssetPair(WCT, Incent) myOrder = myAddress.sell(assetPair = WCT_Incent, amount = 100e8, price = 25e8) # post a buy order using Zbs as price asset BTC = pw.Asset('4ZzED8WJXsvuo2MEm2BmZ87Azw8Sx7TVC6ufSUA5LyTV') BTC_ZBS = pw.AssetPair(BTC, pw.ZBS) myOrder = myAddress.buy(assetPair = BTC_ZBS, amount = 1e8, price = 50e8) # cancel an order myOrder.cancel() # or myAddress.cancelOrder(assetPair, myOrder)","title":"Playing with Zbs Matcher node (DEX):"},{"location":"python/#getting-market-data-from-zbs-data-feed-wdf","text":"import zbspy as pw # set the asset pair ZBS_BTC = pw.AssetPair(pw.ZBS, pw.BTC) # get last price and volume print(\"%s %s\" % (ZBS_BTC.last(), ZBS_BTC.volume())) # get ticker ticker = ZBS_BTC.ticker() print(ticker['24h_open']) print(ticker['24h_vwap']) # get last 10 trades trades = ZBS_BTC.trades(10) for t in trades: print(\"%s %s %s %s\" % (t['buyer'], t['seller'], t['price'], t['amount'])) # get last 10 daily OHLCV candles ohlcv = ZBS_BTC.candles(1440, 10) for t in ohlcv: print(\"%s %s %s %s %s\" % (t['open'], t['high'], t['low'], t['close'], t['volume']))","title":"Getting Market Data from Zbs Data Feed (WDF):"},{"location":"python/#lpos","text":"import zbspy as pw # connect to a local testnet node pw.setNode(node = 'http://127.0.0.1:7431', chain = 'testnet') myAddress = pw.Address(privateKey = 'CsBpQpNE3Z1THNMS9vJPaXqYwN9Hgmhd9AsAPrM3tiuJ') minerAddress = pw.Address('3NBThmVJmcexzJ9itP9KiiC2K6qnGQwpqMq') # lease 1000 Zbs to minerAddress leaseId = myAddress.lease(minerAddress, 100000000000) # revoke the lease myAddress.leaseCancel(leaseId)","title":"LPOS"},{"location":"python/#using-zbspy-in-a-python-shell","text":"","title":"Using ZbsPy in a Python shell"},{"location":"python/#check-an-address-balance","text":">>> import zbspy as pw >>> pw.Address('3P31zvGdh6ai6JK6zZ18TjYzJsa1B83YPoj') address = 3P31zvGdh6ai6JK6zZ18TjYzJsa1B83YPoj publicKey = privateKey = seed = balances: Zbs = 1186077288304570 BDMRyZsmDZpgKhdM7fUTknKcUbVVkDpMcqEj31PUzjMy (Tokes) = 43570656915 RRBqh2XxcwAdLYEdSickM589Vb4RCemBCPH5mJaWhU9 (Ripto Bux) = 4938300000000 4rmhfoscYcjz1imNDvtz45doouvrQqDpbX7xdfLB4guF (incentCoffee) = 7 Ftim86CXM6hANxArJXZs2Fq7XLs3nJvgBzzEwQWwQn6N (Zbs) = 2117290600000000 E4ip4jzTc4PCvebYn1818T4LNoYBVL3Y4Y4dMPatGwa9 (BitCoin) = 500000000000 FLbGXzrpqkvucZqsHDcNxePTkh2ChmEi4GdBfDRRJVof (Incent) = 12302659925430 GQr2fpkfmWjMaZCbqMxefbiwgvpcNgYdev7xpuX6xqcE (KISS) = 1000 DxG3PLganyNzajHGzvWLjc4P3T2CpkBGxY4J9eJAAUPw (UltraCoin) = 200000000000000 4eWBPyY4XNPsFLoQK3iuVUfamqKLDu5o6zQCYyp9d8Ae (LIKE) = 1000 >>>","title":"Check an address balance:"},{"location":"python/#generate-a-new-address","text":">>> import zbspy as pw >>> pw.Address() address = 3P6WfA4qYtkgwVAsWiiB6yaea2X8zyXncJh publicKey = EYNuSmW4Adtcc6AMCZyxkiHMPmF2BZ2XxvjpBip3UFZL privateKey = CtMQWJZqfc7PRzSWiMKaGmWFm4q2VN5fMcYyKDBPDx6S seed = seven wrist bargain hope pattern banner plastic maple student chaos grit next space visa answer balances: Zbs = 0 >>>","title":"Generate a new address:"},{"location":"python/#check-an-asset","text":">>> import zbspy as pw >>> pw.Asset('DHgwrRvVyqJsepd32YbBqUeDH4GJ1N984X8QoekjgH8J') status = Issued assetId = DHgwrRvVyqJsepd32YbBqUeDH4GJ1N984X8QoekjgH8J issuer = 3PPKF2pH4KMYgsDixjrhnWrPycVHr1Ye37V name = ZbsCommunity description = Zbs community token. quantity = 1000000000 decimals = 2 reissuable = False","title":"Check an asset:"},{"location":"python/#post-an-order-and-check-its-status","text":">>> myOrder = myAddress.buy(pw.AssetPair(token1, token2), 1, 25) >>> myOrder status = Accepted id = ARZdYgfXz3ksRMvhnGeLLJnn3CQnz7RCa7U6dVw3zert asset1 = AFzL992FQbhcgSZGKDKAiRWcjtthM55yVCE99hwbHf88 asset2 = 49Aha2RR2eunR3KZFwedfdi7K9v5MLQbLYcmVdp2QkZT sender.address = 3P6WfA4qYtkgwVAsWiiB6yaea2X8zyXncJh sender.publicKey = EYNuSmW4Adtcc6AMCZyxkiHMPmF2BZ2XxvjpBip3UFZL matcher = http://127.0.0.1:7442","title":"Post an order and check its status:"},{"location":"python/#cancel-the-order","text":">>> myOrder.cancel() >>> myOrder status = Cancelled id = ARZdYgfXz3ksRMvhnGeLLJnn3CQnz7RCa7U6dVw3zert asset1 = AFzL992FQbhcgSZGKDKAiRWcjtthM55yVCE99hwbHf88 asset2 = 49Aha2RR2eunR3KZFwedfdi7K9v5MLQbLYcmVdp2QkZT sender.address = 3P6WfA4qYtkgwVAsWiiB6yaea2X8zyXncJh sender.publicKey = EYNuSmW4Adtcc6AMCZyxkiHMPmF2BZ2XxvjpBip3UFZL matcher = http://127.0.0.1:7442","title":"Cancel the order"},{"location":"python/#offline-signing-and-custom-timestamps","text":"","title":"Offline signing and custom timestamps"},{"location":"python/#offline-signing-a-future-transaction","text":">>> import zbspy as pw >>> pw.setOffline() >>> myAddress=pw.Address(privateKey=\"F2jVbjrKzjUsZ1AQRdnd8MmxFc85NQz5jwvZX4BXswXv\") >>> recipient=pw.Address(\"3P8Ya6Ary5gzwnzbBXDp3xjeNG97JEiPcdA\") # sign a future tx to transfer 100 ZBS to recipient # the tx is valid on Jan 1st, 2020 12:00pm >>> myAddress.sendZbs(recipient, amount=100e8, timestamp=1577880000000) {'api-endpoint': '/assets/broadcast/transfer', 'api-type': 'POST', 'api-data': '{\"fee\": 100000, \"timestamp\": 1577880000000, \"senderPublicKey\": \"27zdzBa1q46RCMamZ8gw2xrTGypZnbzXs5J1Y2HbUmEv\", \"amount\": 10000000000, \"attachment\": \"\", \"recipient\": \"3P8Ya6Ary5gzwnzbBXDp3xjeNG97JEiPcdA\" \"signature\": \"YetPopTJWC4WBPXbneWv9g6YEp6J9g9rquZWjewjdQnFbmaxtXjrRsUu69NZzHebVzUGLrhQiFFoguXJwdUn8BH\"}'}","title":"Offline signing a future transaction:"},{"location":"python/#offline-signing-time-lockunlock-transactions","text":">>> import zbspy as pw >>> pw.setOffline() >>> myAddress=pw.Address(privateKey=\"F2jVbjrKzjUsZ1AQRdnd8MmxFc85NQz5jwvZX4BXswXv\") # generate a lockbox address >>> lockAddress=pw.Address() # sign the 'lock' tx to send 100e8 to the lockbox (valid on Nov 1st, 2017) >>> myAddress.sendZbs(lockAddress, 100e8, timestamp=1509537600000) {'api-endpoint': '/assets/broadcast/transfer', 'api-type': 'POST', 'api-data': '{\"fee\": 100000, \"timestamp\": 1509537600000, \"senderPublicKey\": \"27zdzBa1q46RCMamZ8gw2xrTGypZnbzXs5J1Y2HbUmEv\", \"amount\": 10000000000, \"attachment\": \"\", \"recipient\": \"3P3UbyQM9W7WzTgjYkLuBrPZZeWsiUtCcpv\", \"signature\": \"5VgT6qWxJwxEyrxFNfsi67QqbyUiGq9Ka7HVzgovRTTDT8nLRyuQv2wBAJQhRiXDkTTV6zsQmHnBkh8keCaFPoNT\"}'} # sign the 'unlock' tx to send funds back to myAddress (valid on Jan 1st, 2020) >>> lockAddress.sendZbs(myAddress, 100e8-200000, txFee=200000, timestamp=1577880000000) {'api-endpoint': '/assets/broadcast/transfer', 'api-type': 'POST', 'api-data': '{\"fee\": 200000, \"timestamp\": 1577880000000, \"senderPublicKey\": \"52XnBGnAVZmw1CHo9aJPiMsVMiTWeNGSNN9aYJ7cDtx4\", \"amount\": 9999800000, \"attachment\": \"\", \"recipient\": \"3P7tfdCaTyYCfg5ojxNahEJDSS4MZ7ybXBY\", \"signature\": \"3beyz1sqKefP96LaXWT3CxdPRW86DAxcj6wgWPyyKq3SgdotVqnKyWXDyeHnBzCq1nC7JA9CChTmo1c1iVAv6C4T\"}'} # delete lockbox address and private key >>> del lockAddress","title":"Offline signing time lock/unlock transactions:"},{"location":"python/#connecting-to-a-different-node-or-chain","text":"ZbsPy supports both mainnet and testnet chains. By default, ZbsPy connects to the mainnet RPC server at https://nodes.0bsnetwork.com. It's possible to specify a different server and chain with the setNode() function import zbspy as pw # connects to a local testnet node pw.setNode(node = 'http://127.0.0.1:7431', chain = 'testnet') # connects to a local mainnet node pw.setNode(node = 'http://127.0.0.1:7441', chain = 'mainnet')","title":"Connecting to a different node or chain"},{"location":"react/","text":"zbs-react A React Native library for interacting with 0bsNetwork. Currently, the functions implemented allow you to do the following; Generate Addres - This creates a new wallet for your user, and returns an Address, and a Seed Phrase. You should store the seed phrase in your app (Encrypted, for production), so you can use it for future transactions. The address is the bit you give to the user! SaveData - This creates a transaction that saves data to the blockchain. You can use this to save a json object to the blockchain. In return, you get a transaction ID that you can use to see the data once its on the blockchain at https://explorer.0bsnetwork.com by searching the transaction ID. You can also use that URL as a permalink, take a look at the URL format, should you need to link to this from your app to prove the data is saved. sendTokens - This method allows you to transfer ZBS coin, or another token (Given an assetId) to another address, given a seed (Thus a private key). generateDocumentHash - This creates a document hash for a file uploaded, however its currently only implemented in Android, and is experimental. Getting started $ npm install 0bsnetwork/zbs-react --save Mostly automatic installation $ react-native link 0bsnetwork/zbs-react For Android, Add below code in your app gradle file android { defaultConfig { multiDexEnabled true } } IMPORTANT: when using `generateDocumentHash` function it's necessary to pass absolute file path and request permissions (on Android) to read on the external storage, here an example: [React Native Offical Doc] (https://facebook.github.io/react-native/docs/permissionsandroid) Usage GenerateAddress import RN0bsnetwork from \"zbs-react\"; const response = await RN0bsnetwork.generateAddress(); var responseData = JSON.parse(response); this.setState({ seed: responseData.seed, address: responseData.address }); saveData import RN0bsnetwork from \"zbs-react\"; let dataArray = [ { \"type\": \"integer\", \"key\": \"integerVal\", \"value\": 1 }, { \"type\": \"boolean\", \"key\": \"booleanVal\", \"value\": true }, { \"type\": \"string\", \"key\": \"stringVal\", \"value\": \"hello\" } ] let transfer = {data: dataArray, SEED_DATA: 'my long seed phrase ', NODE_URL: 'https://node1.testnet-0bsnetwork.com', assetId: '47dNzPs4KPFZchaahiDCLwsPSMsPDgy9CXfnutieHxMc'} const transactionLog = await RN0bsnetwork.makeTransfer(transfer); console.log(transactionLog); sendTokens import RN0bsnetwork from \"zbs-react\"; let transfer = {amount: 50, recipient:'3NBvF4xAGXJyrJNyS8B1yjrpBRdyT53MD6L', SEED_DATA: 'my long seed phrase ', NODE_URL: 'https://node1.testnet-0bsnetwork.com', assetId: '47dNzPs4KPFZchaahiDCLwsPSMsPDgy9CXfnutieHxMc'} // Note: Exclude assetId to send ZBS. const transactionLog = await RN0bsnetwork.makeTransfer(transfer); console.log(transactionLog); For all issues, questions or suggestions, raise an issue or message @justJamesDev on Telegram or raise a PR, All contributions welcome!","title":"React Library"},{"location":"react/#zbs-react","text":"A React Native library for interacting with 0bsNetwork. Currently, the functions implemented allow you to do the following; Generate Addres - This creates a new wallet for your user, and returns an Address, and a Seed Phrase. You should store the seed phrase in your app (Encrypted, for production), so you can use it for future transactions. The address is the bit you give to the user! SaveData - This creates a transaction that saves data to the blockchain. You can use this to save a json object to the blockchain. In return, you get a transaction ID that you can use to see the data once its on the blockchain at https://explorer.0bsnetwork.com by searching the transaction ID. You can also use that URL as a permalink, take a look at the URL format, should you need to link to this from your app to prove the data is saved. sendTokens - This method allows you to transfer ZBS coin, or another token (Given an assetId) to another address, given a seed (Thus a private key). generateDocumentHash - This creates a document hash for a file uploaded, however its currently only implemented in Android, and is experimental.","title":"zbs-react"},{"location":"react/#getting-started","text":"$ npm install 0bsnetwork/zbs-react --save","title":"Getting started"},{"location":"react/#mostly-automatic-installation","text":"$ react-native link 0bsnetwork/zbs-react","title":"Mostly automatic installation"},{"location":"react/#for-android-add-below-code-in-your-app-gradle-file","text":"android { defaultConfig { multiDexEnabled true } } IMPORTANT: when using `generateDocumentHash` function it's necessary to pass absolute file path and request permissions (on Android) to read on the external storage, here an example: [React Native Offical Doc] (https://facebook.github.io/react-native/docs/permissionsandroid)","title":"For Android, Add below code in your app gradle file"},{"location":"react/#usage","text":"","title":"Usage"},{"location":"react/#generateaddress","text":"import RN0bsnetwork from \"zbs-react\"; const response = await RN0bsnetwork.generateAddress(); var responseData = JSON.parse(response); this.setState({ seed: responseData.seed, address: responseData.address });","title":"GenerateAddress"},{"location":"react/#savedata","text":"import RN0bsnetwork from \"zbs-react\"; let dataArray = [ { \"type\": \"integer\", \"key\": \"integerVal\", \"value\": 1 }, { \"type\": \"boolean\", \"key\": \"booleanVal\", \"value\": true }, { \"type\": \"string\", \"key\": \"stringVal\", \"value\": \"hello\" } ] let transfer = {data: dataArray, SEED_DATA: 'my long seed phrase ', NODE_URL: 'https://node1.testnet-0bsnetwork.com', assetId: '47dNzPs4KPFZchaahiDCLwsPSMsPDgy9CXfnutieHxMc'} const transactionLog = await RN0bsnetwork.makeTransfer(transfer); console.log(transactionLog);","title":"saveData"},{"location":"react/#sendtokens","text":"import RN0bsnetwork from \"zbs-react\"; let transfer = {amount: 50, recipient:'3NBvF4xAGXJyrJNyS8B1yjrpBRdyT53MD6L', SEED_DATA: 'my long seed phrase ', NODE_URL: 'https://node1.testnet-0bsnetwork.com', assetId: '47dNzPs4KPFZchaahiDCLwsPSMsPDgy9CXfnutieHxMc'} // Note: Exclude assetId to send ZBS. const transactionLog = await RN0bsnetwork.makeTransfer(transfer); console.log(transactionLog); For all issues, questions or suggestions, raise an issue or message @justJamesDev on Telegram or raise a PR, All contributions welcome!","title":"sendTokens"},{"location":"signer/","text":"Signer API This enables you to sign and broadcast a transaction only having the key and transaction data. Note: This is just for POC's and shouldn't be used on a production environment Usage Data Transaction POST https://signer.testnet-0bsnetwork.com/data Accept: application/json Content-Type: application/json { \"seed\": \"seed phrase here\", \"data\": [ { \"key\": \"integerVal\", \"value\": 1 }, { \"key\": \"booleanVal\", \"value\": true }, { \"key\": \"stringVal\", \"value\": \"hello\" }, { \"key\": \"binaryVal\", \"value\": [1, 2, 3, 4] } ] } RESPONSE: { \"type\": 12, \"version\": 1, \"senderPublicKey\": \"3np4zRL2mjYSFcpTzbGtQzUePAEByxEADgQCPJB7Dguq\", \"fee\": 3000000, \"timestamp\": 1574975434582, \"proofs\": [ \"3tXuGRUGbV7xVWTGN79cRtkyrq4XWoN6wGH9KFiFn14P4EJR51LDenfvrP34YUZnXvAg4i7iUa728h1LdVVsjSdd\" ], \"id\": \"EDoej1N3zEWXs9XGNwBjJHPyQECA577dQfBe2LN5Pvh2\", \"data\": [ { \"type\": \"integer\", \"key\": \"integerVal\", \"value\": 1 }, { \"type\": \"boolean\", \"key\": \"booleanVal\", \"value\": true }, { \"type\": \"string\", \"key\": \"stringVal\", \"value\": \"hello\" }, { \"type\": \"binary\", \"key\": \"binaryVal\", \"value\": \"base64:AQIDBA==\" } ] }","title":"Transaction Signer (POC)"},{"location":"signer/#signer-api","text":"This enables you to sign and broadcast a transaction only having the key and transaction data. Note: This is just for POC's and shouldn't be used on a production environment","title":"Signer API"},{"location":"signer/#usage","text":"","title":"Usage"},{"location":"signer/#data-transaction","text":"POST https://signer.testnet-0bsnetwork.com/data Accept: application/json Content-Type: application/json { \"seed\": \"seed phrase here\", \"data\": [ { \"key\": \"integerVal\", \"value\": 1 }, { \"key\": \"booleanVal\", \"value\": true }, { \"key\": \"stringVal\", \"value\": \"hello\" }, { \"key\": \"binaryVal\", \"value\": [1, 2, 3, 4] } ] } RESPONSE: { \"type\": 12, \"version\": 1, \"senderPublicKey\": \"3np4zRL2mjYSFcpTzbGtQzUePAEByxEADgQCPJB7Dguq\", \"fee\": 3000000, \"timestamp\": 1574975434582, \"proofs\": [ \"3tXuGRUGbV7xVWTGN79cRtkyrq4XWoN6wGH9KFiFn14P4EJR51LDenfvrP34YUZnXvAg4i7iUa728h1LdVVsjSdd\" ], \"id\": \"EDoej1N3zEWXs9XGNwBjJHPyQECA577dQfBe2LN5Pvh2\", \"data\": [ { \"type\": \"integer\", \"key\": \"integerVal\", \"value\": 1 }, { \"type\": \"boolean\", \"key\": \"booleanVal\", \"value\": true }, { \"type\": \"string\", \"key\": \"stringVal\", \"value\": \"hello\" }, { \"type\": \"binary\", \"key\": \"binaryVal\", \"value\": \"base64:AQIDBA==\" } ] }","title":"Data Transaction"},{"location":"smartcontracts/","text":"Smart Contracts Smart Contracts pn our platform allow to change the default behaviour of accounts and assets. Smart contracts are: Scripts written using RIDE programming language. Predicates over account or asset transactions, which always should return true or false. Always passive and not callable. Smart Contract Script has access to: Blockchain height. There is height() function in the global scope of a script which returns the blockchain height at the execution time. Current transaction fields. There is tx variable in the global scope of a script which contains all fields of current outgoing transaction, including proofs array. Proofs array is not available in an asset script. Proofs. Any transaction can contain an array of proofs up to 8 elements. By default proofs array used for signatures, but you can put any data in the array (each element is up to 64 bytes). Key-value storage of any account. Data saved by a data transaction. Smart Accounts 0bsNetwork uses an account-based model, there are no inputs and outputs of transactions like in some other blockchain networks. All assets and data associates with an account and bound to its' public key. By default, public key \u201cowns\u201d assets and stores key-value data attached by data transactions. To spend funds or update key-value storage the sender provides a valid signature matching transaction body and public key. The main idea that before the transaction is submitted to be included in the next block, the account checks if the transaction meets certain requirements, defined in a script. The script is attached to the account so the account can validate every transaction before confirming it. Smart contract (account script) allows us to change the default behaviour of an account by sending a setScriptTransaction. It's important that the smart account does not store any data on the blockchain. A smart account will only have access to blockchain state values that can be retrieved and executed relatively fast, in a \u201cconstant\u201d time. Any normal account/address can become a smart account. How to work with state If you're familiar with Ethereum smart contracts model you have to consider the main difference between them and our Smart Contracts: 0bsnetwork smart contracts do not have their own state. There is a smart account state managed by data transactions. If you need to work with state you have to use data transactions and manage them with smart account scripts. Gas and fees The simplicity of account scripts makes the system very scalable in terms of throughput and smart accounts work without \u201cgas\u201d, which means that costs are always known upfront. Transactions from smart account or with smart asset require additional an additional fee documented in transactions Restrictions Smart accounts cannot send transactions themselves or transfer funds according to given conditions, but can read data from the blockchain (for example, the height of a blockchain or signatures from the transaction) and return the result of a predicate obtained on the basis of this data. Smart Assets If we plan to apply constraints on all operations for a specific asset, we cannot use a smart account. In our paradigm we have smart assets for this purpose: the script will be attached to the asset and will work in a similar way. Transactions for such assets are valid only if the script returns True. For example, a script can verify proofs from a transaction, check if a notary/escrow approves the transaction, and that operations with the asset are not locked for a specified time. The script for the token is invoked upon the following operations with an asset: Transfer Transaction MassTransfer Transaction Reissue Transaction Burn Transaction ExchangeTransaction SetAssetScriptTransaction Getting Started The best way to get started with RIDE and smart contracts is to dive right in and check out some examples, the lanuage is easy and readable, and our IDE already has samples pre-installed that you can load up. Smart Account Examples An account can trade only with BTC let cooperPubKey = base58'BVqYXrapgJP9atQccdBPAgJPwHDKkh6A8' let BTCId = base58'BTC Asset ID' match tx { case o: Order => sigVerify(tx.bodyBytes, tx.proofs[0], cooperPubKey ) && (o.assetPair.priceAsset == BTCId || o.assetPair.amountAsset == BTCId) case _ => sigVerify(tx.bodyBytes, tx.proofs[0], cooperPubKey ) } Buy back custom asset on specified price in ZBS let myAssetId = base58'BVqYXrapgJP9atQccdBPAgJPwHDKkh6B9' let cooperPubKey = base58'BVqYXrapgJP9atQccdBPAgJPwHDKkh6A8' match tx { case o: Order => o.assetPair.priceAsset == base58'' && o.assetPair.amountAsset == myAssetId && o.price == 500000 && o.amount == 1000 && o.orderType == Buy case _ => sigVerify(tx.bodyBytes, tx.proofs[0], cooperPubKey ) } Smart Asset Examples Issue an unburnable asset To issue an unburnable asset you can use pattern matching with a false value to BurnTransaction: match tx { case t : BurnTransaction => false case _ => true } Asset You can freeze your assets till the certain height by defining a target height variable: let targetHeight = 1500000 height >= targetHeight Getting a share after each asset transfer For requiring a fee in a certain asset to get a share after each transfer you can use TransferTransaction depending on the asset id: match tx { case t : TransferTransaction => t.feeAssetId == base58'oWgJN6YGZFtZrV8BWQ1PGktZikgg7jzGmtm16Ktyvjd' case _ => true } Transferring by issuer permission You can restrict the token transfer option to be done only by the token issuer's permission (commitment/debt label): match tx { case tx : TransferTransaction => let issuer = Address(base58'3P6ms9EotRX8JwSrebeTXYVnzpsGCrKWLv4') isDefined(getInteger(issuer, toBase58String(tx.id))) case _ => false } Issue an untransferable asset To make the asset untransferable, you can assign a false value to TransferTransaction, MassTransferTransaction and ExchangeTransaction: match tx { case t : TransferTransaction | MassTransferTransaction | ExchangeTransaction => false case _ => true } Asset tradable only with BTC To allow asset trading only with bitcoins you can do as here: let BTCId = base58'8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS' match tx { case t : ExchangeTransaction => t.sellOrder.assetPair.priceAsset == BTCId || t.sellOrder.assetPair.amountAsset == BTCId case _ => true } Require using a certain matcher To define a certain matcher, you can assign the matcher address as a sender value: match tx { case t : ExchangeTransaction => t.sender == addressFromString(\"3PJaDyprvekvPXPuAtxrapacuDJopgJRaU3\") case _ => true } Only allow data transactions and where longitude and latitude are within some limits Treat the long and lat as integers. Send a data transaction that should be within this box. This is only a demo to show how a contract can limit data. Ideally one should check against some data that can be changed, such as another address where data is uploaded via a data contract. However, this should be sufficient to demo the concept. let oracle = extract(addressFromString(\"3MqpUtDotRccXE164rSPygwXUSx2eG85EPs\")) let minLong = extract(getInteger(oracle, \"minLong\")) let maxLong = extract(getInteger(oracle, \"maxLong\")) let minLat = extract(getInteger(oracle, \"minLat\")) let maxLat = extract(getInteger(oracle, \"maxLat\")) match (tx) { case dtx:DataTransaction => ( let payloadSize = size(dtx.data) let longitude = dtx.data[0].key let latitude = dtx.data[1].key let longitudeAsInteger = extract(getInteger(dtx.data, longitude)) let latitudeAsInteger = extract(getInteger(dtx.data, latitude)) if (longitudeAsInteger > minLong && longitudeAsInteger < maxLong && latitudeAsInteger < maxLat && latitudeAsInteger > minLat ) then ( true ) else ( false ) ) case _ => true }","title":"Smart Contracts"},{"location":"smartcontracts/#smart-contracts","text":"Smart Contracts pn our platform allow to change the default behaviour of accounts and assets. Smart contracts are: Scripts written using RIDE programming language. Predicates over account or asset transactions, which always should return true or false. Always passive and not callable. Smart Contract Script has access to: Blockchain height. There is height() function in the global scope of a script which returns the blockchain height at the execution time. Current transaction fields. There is tx variable in the global scope of a script which contains all fields of current outgoing transaction, including proofs array. Proofs array is not available in an asset script. Proofs. Any transaction can contain an array of proofs up to 8 elements. By default proofs array used for signatures, but you can put any data in the array (each element is up to 64 bytes). Key-value storage of any account. Data saved by a data transaction.","title":"Smart Contracts"},{"location":"smartcontracts/#smart-accounts","text":"0bsNetwork uses an account-based model, there are no inputs and outputs of transactions like in some other blockchain networks. All assets and data associates with an account and bound to its' public key. By default, public key \u201cowns\u201d assets and stores key-value data attached by data transactions. To spend funds or update key-value storage the sender provides a valid signature matching transaction body and public key. The main idea that before the transaction is submitted to be included in the next block, the account checks if the transaction meets certain requirements, defined in a script. The script is attached to the account so the account can validate every transaction before confirming it. Smart contract (account script) allows us to change the default behaviour of an account by sending a setScriptTransaction. It's important that the smart account does not store any data on the blockchain. A smart account will only have access to blockchain state values that can be retrieved and executed relatively fast, in a \u201cconstant\u201d time. Any normal account/address can become a smart account.","title":"Smart Accounts"},{"location":"smartcontracts/#how-to-work-with-state","text":"If you're familiar with Ethereum smart contracts model you have to consider the main difference between them and our Smart Contracts: 0bsnetwork smart contracts do not have their own state. There is a smart account state managed by data transactions. If you need to work with state you have to use data transactions and manage them with smart account scripts.","title":"How to work with state"},{"location":"smartcontracts/#gas-and-fees","text":"The simplicity of account scripts makes the system very scalable in terms of throughput and smart accounts work without \u201cgas\u201d, which means that costs are always known upfront. Transactions from smart account or with smart asset require additional an additional fee documented in transactions","title":"Gas and fees"},{"location":"smartcontracts/#restrictions","text":"Smart accounts cannot send transactions themselves or transfer funds according to given conditions, but can read data from the blockchain (for example, the height of a blockchain or signatures from the transaction) and return the result of a predicate obtained on the basis of this data.","title":"Restrictions"},{"location":"smartcontracts/#smart-assets","text":"If we plan to apply constraints on all operations for a specific asset, we cannot use a smart account. In our paradigm we have smart assets for this purpose: the script will be attached to the asset and will work in a similar way. Transactions for such assets are valid only if the script returns True. For example, a script can verify proofs from a transaction, check if a notary/escrow approves the transaction, and that operations with the asset are not locked for a specified time. The script for the token is invoked upon the following operations with an asset: Transfer Transaction MassTransfer Transaction Reissue Transaction Burn Transaction ExchangeTransaction SetAssetScriptTransaction","title":"Smart Assets"},{"location":"smartcontracts/#getting-started","text":"The best way to get started with RIDE and smart contracts is to dive right in and check out some examples, the lanuage is easy and readable, and our IDE already has samples pre-installed that you can load up.","title":"Getting Started"},{"location":"smartcontracts/#smart-account-examples","text":"","title":"Smart Account Examples"},{"location":"smartcontracts/#an-account-can-trade-only-with-btc","text":"let cooperPubKey = base58'BVqYXrapgJP9atQccdBPAgJPwHDKkh6A8' let BTCId = base58'BTC Asset ID' match tx { case o: Order => sigVerify(tx.bodyBytes, tx.proofs[0], cooperPubKey ) && (o.assetPair.priceAsset == BTCId || o.assetPair.amountAsset == BTCId) case _ => sigVerify(tx.bodyBytes, tx.proofs[0], cooperPubKey ) }","title":"An account can trade only with BTC"},{"location":"smartcontracts/#buy-back-custom-asset-on-specified-price-in-zbs","text":"let myAssetId = base58'BVqYXrapgJP9atQccdBPAgJPwHDKkh6B9' let cooperPubKey = base58'BVqYXrapgJP9atQccdBPAgJPwHDKkh6A8' match tx { case o: Order => o.assetPair.priceAsset == base58'' && o.assetPair.amountAsset == myAssetId && o.price == 500000 && o.amount == 1000 && o.orderType == Buy case _ => sigVerify(tx.bodyBytes, tx.proofs[0], cooperPubKey ) }","title":"Buy back custom asset on specified price in ZBS"},{"location":"smartcontracts/#smart-asset-examples","text":"","title":"Smart Asset Examples"},{"location":"smartcontracts/#issue-an-unburnable-asset","text":"To issue an unburnable asset you can use pattern matching with a false value to BurnTransaction: match tx { case t : BurnTransaction => false case _ => true }","title":"Issue an unburnable asset"},{"location":"smartcontracts/#asset","text":"You can freeze your assets till the certain height by defining a target height variable: let targetHeight = 1500000 height >= targetHeight","title":"Asset"},{"location":"smartcontracts/#getting-a-share-after-each-asset-transfer","text":"For requiring a fee in a certain asset to get a share after each transfer you can use TransferTransaction depending on the asset id: match tx { case t : TransferTransaction => t.feeAssetId == base58'oWgJN6YGZFtZrV8BWQ1PGktZikgg7jzGmtm16Ktyvjd' case _ => true }","title":"Getting a share after each asset transfer"},{"location":"smartcontracts/#transferring-by-issuer-permission","text":"You can restrict the token transfer option to be done only by the token issuer's permission (commitment/debt label): match tx { case tx : TransferTransaction => let issuer = Address(base58'3P6ms9EotRX8JwSrebeTXYVnzpsGCrKWLv4') isDefined(getInteger(issuer, toBase58String(tx.id))) case _ => false }","title":"Transferring by issuer permission"},{"location":"smartcontracts/#issue-an-untransferable-asset","text":"To make the asset untransferable, you can assign a false value to TransferTransaction, MassTransferTransaction and ExchangeTransaction: match tx { case t : TransferTransaction | MassTransferTransaction | ExchangeTransaction => false case _ => true }","title":"Issue an untransferable asset"},{"location":"smartcontracts/#asset-tradable-only-with-btc","text":"To allow asset trading only with bitcoins you can do as here: let BTCId = base58'8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS' match tx { case t : ExchangeTransaction => t.sellOrder.assetPair.priceAsset == BTCId || t.sellOrder.assetPair.amountAsset == BTCId case _ => true }","title":"Asset tradable only with BTC"},{"location":"smartcontracts/#require-using-a-certain-matcher","text":"To define a certain matcher, you can assign the matcher address as a sender value: match tx { case t : ExchangeTransaction => t.sender == addressFromString(\"3PJaDyprvekvPXPuAtxrapacuDJopgJRaU3\") case _ => true }","title":"Require using a certain matcher"},{"location":"smartcontracts/#only-allow-data-transactions-and-where-longitude-and-latitude-are-within-some-limits","text":"Treat the long and lat as integers. Send a data transaction that should be within this box. This is only a demo to show how a contract can limit data. Ideally one should check against some data that can be changed, such as another address where data is uploaded via a data contract. However, this should be sufficient to demo the concept. let oracle = extract(addressFromString(\"3MqpUtDotRccXE164rSPygwXUSx2eG85EPs\")) let minLong = extract(getInteger(oracle, \"minLong\")) let maxLong = extract(getInteger(oracle, \"maxLong\")) let minLat = extract(getInteger(oracle, \"minLat\")) let maxLat = extract(getInteger(oracle, \"maxLat\")) match (tx) { case dtx:DataTransaction => ( let payloadSize = size(dtx.data) let longitude = dtx.data[0].key let latitude = dtx.data[1].key let longitudeAsInteger = extract(getInteger(dtx.data, longitude)) let latitudeAsInteger = extract(getInteger(dtx.data, latitude)) if (longitudeAsInteger > minLong && longitudeAsInteger < maxLong && latitudeAsInteger < maxLat && latitudeAsInteger > minLat ) then ( true ) else ( false ) ) case _ => true }","title":"Only allow data transactions and where longitude and latitude are within some limits"},{"location":"transactions/","text":"Transactions Transaction Types Each transaction type is given an integer to represent it as follows. The transaction fee is included below too, though libraries should have these set by default. Transaction Type Name Description Fee (ZBS) 3 Issue Create a new token / asset 500.00 4 Transfer Send ZBS or Token to another address 0.05 5 ReIssue Issue more of your token 200.00 6 Burn Destroy X tokens 5.00 7 Exchange A Trade. Buy / Sell 0.20 8 Lease Start leasing to another address 5.00 9 LeaseCancel Cancel a Lease 1.00 10 CreateAlias Create an alias for your address 10 11 MassTransfer Send up to 100 Transfers in 1 transaction 0.05 12 Data Save data to the blockchain 0.03 13 SetScript Add a script to an Address 10.00 14 CustomFee Setup a Custom Fee for your Asset 50.00 15 SetAsset Set a script on an asset 10.00 16 ContractInvoke Run a contract 0.10 17 Index 18 CustomFee Extra Fee: 0.01 (In addition to fee when operating with smart assets or accounts) Transaction Formats The below sections demonstrate the JSON transaction format that is required to make a transaction. When signing a transaction on a Node, you can exclude the signature/proofs field as the server will give you this back. Within the transaction JSON, Fee's are expressed without decimal values, so ZBS has 8 decimal places, and 100000000 represents 1 ZCL within the transaction JSON. Issue / ReIssue Transaction Issue and ReIssue take the same format apart from the type { \"senderPublicKey\":\"2M25DqL2W4rGFLCFadgATboS8EPqyWAN3DjH12AH5Kdr\", \"quantity\": 50000 \"fee\": 50000000000, \"description\":\"My New Token\", \"type\":3 / 5, \"version\":2, \"reissuable\":true, \"script\":\"base64:AQa3b8tH\", // Optional Script for 'Smart Assets' \"sender\":\"3Mz9N7YPfZPWGd4yYaX6H53Gcgrq6ifYiH7\", \"feeAssetId\":null, // When paying using custom fees \"chainId\":84, // 84 (T) for testnet 90 (Z) for mainnet \"proofs\":[\"4yjVxzrLuXUq5y2QCa2LDn1Fp9P63hPBmqDLGQCqn41EB1uZ1pys79NP81h7FxRBnZSbpNGbz1xjwckHcPAQHmFX\"], \"decimals\":2, \"name\":\"MyTestToken\" } Transfer Transaction { \"senderPublicKey\":\"4c5K4kGeRdrnSYZ9wngQKSozikVgfxmDEuViirsyUHwd\", \"amount\":110000000 fee\":500000, \"type\":4, \"version\":2, \"attachment\":\"\", \"sender\":\"3MyT3r1S8xvKtiKnLgVNNiSAiQdnMbffBQy\", \"feeAssetId\":null, \"proofs\":[\"2KFbYWi9BJwDG9dbiJQzC9qJPpu4Ug8Ybs331fQbX9FAkEpEtrj9DKvwNG7cb2m98DV6NCoKH4MBVtGGFsnQWPV6\"], \"assetId\":null, // If we are sending an asset, null for ZBS \"recipient\":\"3MqEisFsWdhvDMAKBwZzZv4niVsfJJtxcaw\", \"feeAsset\":null } Burn Transaction Burning tokens can be useful for systems where a token is used to activate or fund a service and once the service has been used the token can be burnt. { type: 6, id: 'ComWcac6FMKBT4sNNyNwDDFG8T63s3xorV4M7x8y6TVm', sender: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', senderPublicKey: '4vR9m3vFuAWqQ6zJWDeqnPCMgLsxKkz2sQcAcEjHduU', fee: 500000000, timestamp: 1561326417304, proofs: [ '3c2ao2uF2T6sxLJqHZSdAY2brjHHeUVQqNMDDJPxfh33JAyTeocnAWGt7nw6dwTB2mBEG8CimuC4BP19DCfB98YZ' ], version: 2, assetId: 'BiuhdjnH9qxgfax52zXgJw3b5ArxCdA4q8kYECqWoEYT', amount: 1, chainId: 84 } Exchange Transaction { \"senderPublicKey\":\"8QUAqtTckM5B8gvcuP7mMswat9SjKUuafJMusEoSn1Gy\", \"amount\":1000000000, \"fee\":300000, \"type\":7, \"version\":2, \"sellMatcherFee\":30000, \"buyMatcherFee\":300000, \"sender\":\"3N8aZG6ZDfnh8YxS6aNcteobN8eXTWHaBBd\", \"feeAssetId\":null, \"proofs\":[\"4kBxzWXSzbM4jQbi8SmNtZeRJEwUkMzCezf8AQYeu5z124ajpKG9GVJZbHdnRWz9R1Key5opySDbKj6B4zTtZsNF\"], \"price\":90, \"id\":\"28biMwpgZVjAUk5iJnWvphaFgr8Tybwqe6s5JxGTdDWJ\", \"order2\": {\"version\":2, \"id\":\"GaCXusGNDkYZ8iciV3cuUKb7r4awESwocghJXnFyLxYk\", \"sender\":\"3MwBD8xZByEHAnwB69eexgVPAPD5ucw1Rna\",\"senderPublicKey\":\"HHonWv97CD2XXgRNbny7aCWP8amgYatCaTEthq38P1Do\",\"matcherPublicKey\":\"8QUAqtTckM5B8gvcuP7mMswat9SjKUuafJMusEoSn1Gy\", //Obtained from https://matcher.testnet-0bsnetwork.com/matcher \"assetPair\": { \"amountAsset\":\"4CFzLzP3vBHBev9GyeWm6AP7hm72qn6xELU1je5Wmq8L\", \"priceAsset\":null }, \"orderType\":\"sell\", \"amount\":10000000000, \"price\":90, \"timestamp\":1548657730301, \"expiration\":1551163330301, \"matcherFee\":300000,\"signature\":\"2uX8CedW8oPXqktAwJLm9emFArUimxcXD9pqHnd2mEWJYYJuBChzk59fzB7DVeKnczmosJa4vfAvCzqY8DSoq4Rr\",\"proofs\":[\"2uX8CedW8oPXqktAwJLm9emFArUimxcXD9pqHnd2mEWJYYJuBChzk59fzB7DVeKnczmosJa4vfAvCzqY8DSoq4Rr\"] }, \"order1\": { \"version\":2, \"id\":\"4EFqAQLW8S2Swo3dh5RZ5DXNtfQRDij7Y28RayN3vW7G\", \"sender\":\"3N5h5G6ToFR7cMMzdzR1hvUaMNuz7quCt4H\",\"senderPublicKey\":\"He5xRqcQBzk1VbdH7GP3XdGbB7dLwsvEbyLfNAbVkunJ\",\"matcherPublicKey\":\"8QUAqtTckM5B8gvcuP7mMswat9SjKUuafJMusEoSn1Gy\", //Obtained from https://matcher.testnet-0bsnetwork.com/matcher \"assetPair\": { \"amountAsset\":\"4CFzLzP3vBHBev9GyeWm6AP7hm72qn6xELU1je5Wmq8L\", \"priceAsset\":null }, \"orderType\":\"buy\", \"amount\":1000000000, \"price\":100, \"timestamp\":1548661139113, \"expiration\":1548661439111, \"matcherFee\":300000,\"signature\":\"23mzQgZgjsKBCTLRLS8ktbtP6EZx3gABT9AF63UF4nuhS1o7XJgEGby2umhijo4t8yKuw1CmZ3UVab4A6vtod3H8\",\"proofs\":[\"23mzQgZgjsKBCTLRLS8ktbtP6EZx3gABT9AF63UF4nuhS1o7XJgEGby2umhijo4t8yKuw1CmZ3UVab4A6vtod3H8\"] } } Lease Transaction { \"senderPublicKey\":\"FB5ErjREo817duEBBQUqUdkgoPctQJEYuG3mU7w3AYjc\", \"amount\":1, \"fee\":500000000, \"type\":8, \"version\":2, \"sender\":\"3Mps7CZqB9nUbEirYyCMMoA7VbqrxLvJFSB\", \"feeAssetId\":null, \"proofs\":[\"fkWj6RkV722jhv72BY6Eo5BZ6N4T8nTPcmQVmoBs14Cv53W2VfRE7C9rT1TN4CZfAW2Y2YhVFm24NGZh75eBHq4\"],\"recipient\":\"3NCKpqzSnHmXhZEmqYy4U6RUKUAJDTxWgWP\" } Lease Cancel { \"senderPublicKey\":\"FB5ErjREo817duEBBQUqUdkgoPctQJEYuG3mU7w3AYjc\", \"amount\":1 \"fee\":100000000, \"type\":8, \"version\":2, \"sender\":\"3Mps7CZqB9nUbEirYyCMMoA7VbqrxLvJFSB\", \"feeAssetId\":null, \"proofs\":[\"fkWj6RkV722jhv72BY6Eo5BZ6N4T8nTPcmQVmoBs14Cv53W2VfRE7C9rT1TN4CZfAW2Y2YhVFm24NGZh75eBHq4\"],\"recipient\":\"3NCKpqzSnHmXhZEmqYy4U6RUKUAJDTxWgWP\" } Create Alias { \"senderPublicKey\":\"BVv1ZuE3gKFa6krwWJQwEmrLYUESuUabNCXgYTmCoBt6\", \"sender\":\"3N8S4UtauvDAzpLiaRyDdHn9muexWHhBP4D\", \"feeAssetId\":null, \"proofs\":[\"22QJfRKX7kUQt4qjdnUqZAnhqukqhnofE27uvP8Q5xnBf8M6PCNtWVGq2ngm6m7Voe7duys59D1yU9jhKrmdXDCe\"], \"fee\":1000000000, \"alias\":\"91f452553298770f\", \"id\":\"AD7KmXwoVNc2fXsmaxsHsrnT1tfPF3HsWYtfjFijVsvM\", \"type\":10, \"version\":2 } Mass Transfer { type: 11, id: '48Dn8uK95jL8iZqv81gqv7PxJtbrZihjmg1Zdcs1428P', sender: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', senderPublicKey: '4vR9m3vFuAWqQ6zJWDeqnPCMgLsxKkz2sQcAcEjHduU', fee: 10000000, timestamp: 1561326259593, proofs: [ 'YxmbijFFmNM9goWMoxxcPtHM36TKFVrMfC5i9yZEPtZiqoDZ13M3kQJBw557bi728vmR9ydFYZ847gdoisbCVnM' ], version: 1, assetId: null, attachment: '', transferCount: 2, totalAmount: 2, transfers: [ { recipient: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', amount: 1 }, { recipient: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', amount: 1 } ] } Data { type: 12, id: '3d8fQKQ8Va43vvVzbKJChMrPzQDNgLBH9GaQw23YhdZC', sender: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', senderPublicKey: '4vR9m3vFuAWqQ6zJWDeqnPCMgLsxKkz2sQcAcEjHduU', fee: 3000000, timestamp: 1561326312175, proofs: [ 'mWVbzSuomwiaowrNLBhEFcZE6dfHhK1tYWrqQZ124mum8MJuoksuqVZUjaRUW7rwLw4cEc33unKTzYP4X9ftRu9' ], version: 1, data: [ { key: 'integerVal', type: 'integer', value: 1 }, { key: 'booleanVal', type: 'boolean', value: true }, { key: 'stringVal', type: 'string', value: 'hello' }, { key: 'binaryVal', type: 'binary', value: 'base64:AQIDBA==' } ] } SetScript Set Asset Invoke Script Index { type: 4, id: '8LjTjtAqQscTk5o3VuzViyp5Dk3dPZ9W26ezHUEyi2LW', sender: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', senderPublicKey: '4vR9m3vFuAWqQ6zJWDeqnPCMgLsxKkz2sQcAcEjHduU', fee: 5000000, timestamp: 1561326556314, proofs: [ '5H4KDmjYh5tfe7iurVxyZZnKGwcVrproBJs83kLCgvxUi9bn6S1yiLmnrCsD5Zaijm7eJgvTaTZnS6fdx7aW8xKp' ], version: 2, recipient: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', assetId: null, feeAssetId: null, feeAsset: null, amount: 1, attachment: '' } Custom Fees { type: 14, id: 'HfEnBX9PBkTpNLs5BgxvqmrPQkowb9dogMcSFSSZg9Vq', sender: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', senderPublicKey: '4vR9m3vFuAWqQ6zJWDeqnPCMgLsxKkz2sQcAcEjHduU', fee: 5000000000, timestamp: 1561328515891, proofs: [ 'Qe81c41WbSDwV1wXRVKZK9ze7kPhE5B5wSRB96ZsZ21ZbZ6hSq89accLdHH1gsZXQvC2WphL1VLKNYG1DVkWZwF' ], version: 1, assetId: 'BiuhdjnH9qxgfax52zXgJw3b5ArxCdA4q8kYECqWoEYT', minSponsoredAssetFee: 100 } Signing Transactions Signing transactions manually is quite complex, and usually its best to use a library to do so, however if you find you dont have a library available for your platform of choice, you may need to do it manually. The process involves concatenting the byte values of fields from the transaction to create a long byte array, and signing this using Curve25519 and your private key, and inserting this into the transaction payload. Rather than include excessive details here on how to do that, the below code sample in C Sharp should be readable enough to understand how the process works, and you can also examine the code of our other libraries as they are all open source. If you need specific details or guidance, please do contact us using the details on the Front Page using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Security.Cryptography; using System.Numerics; using DictionaryObject = System.Collections.Generic.Dictionary<string, object>; using org.whispersystems.curve25519.csharp; using System.Reflection; using org.whispersystems.curve25519; using System.IO; using Program; namespace ZbsSignAndBroadcastDataTransaction { class Program { /// <summary> /// This is a raw demonstration of a Data transaction. It's purpose is to save data to the blockchain (Variable TransactionData) - The signing procedure is demonstrated below. /// </summary> // 3MqSRBfLsTzXssscX8crUH88zJegvyrd5WK // Seed Phrase: despair olive coconut design rubber proud silver rotate glow gloom extra income effort about summer // Private Key: Bq6dvj1v48EAyS34Nu6bZS7tWtaxgQnChQrJvxr5x1pM // Public Key: 7cgFXWXTGXemR2yHq1MYx8o7jVKq6Y4Y5bTyaJ478aeG // Replenish Balance: https://explorer.testnet-0bsnetwork.com/faucet private static readonly Curve25519 Cipher = Curve25519.getInstance(Curve25519.BEST); static void Main(string[] args) { byte Version = 1; byte TxType = 12; byte[] SenderPrivateKey; byte[] SenderPublicKey; byte[] transactionBytes; DateTime Timestamp = DateTime.UtcNow; SenderPrivateKey = Base58.Decode(\"Bq6dvj1v48EAyS34Nu6bZS7tWtaxgQnChQrJvxr5x1pM\"); // These are obtained from the client. X25519 Keys SenderPublicKey = Base58.Decode(\"7cgFXWXTGXemR2yHq1MYx8o7jVKq6Y4Y5bTyaJ478aeG\"); var TransactionData = new DictionaryObject { { \"test num\", (long)1 }, { \"test true\", true }, { \"test bytes\", new byte[] { 1, 2, 3, 4, 5}}, { \"test string\", \"Hello!\"} }; // To create a signature, we create a byte array. using (var stream = new MemoryStream()) using (var writer = new BinaryWriter(stream)) { writer.Write(TxType); // First we add the Transaction Type (Its a number.. 12 is Data transaction) writer.Write(Version); // Transaction version is set to 1 writer.Write(SenderPublicKey); writer.WriteShort((short)TransactionData.Count); // Next we set the number of data items we are sending, in this case, theres 4 (TransactionData) foreach (var pair in TransactionData) // For each data item we need to add its Length, Key and its value { var key = Encoding.UTF8.GetBytes(pair.Key); writer.WriteShort((short)key.Length); writer.Write(key); writer.WriteObject(pair.Value); } writer.WriteLong(Timestamp.ToLong()); writer.WriteLong(3000000); //Arbitary fee transactionBytes = stream.ToArray(); } // Next we take the byte array and sign it to generate a Proof. var proof = Cipher.calculateSignature(SenderPrivateKey, transactionBytes); // And finally, create a JSON payload to broadcast the transaction to the network var finalTransaction = new DictionaryObject { {\"type\", (byte) 12}, {\"version\", Version}, {\"senderPublicKey\", SenderPublicKey.ToBase58() }, {\"sender\", \"3MqSRBfLsTzXssscX8crUH88zJegvyrd5WK\" }, {\"data\", TransactionData.Select(pair => new DictionaryObject // Add each data entry to the JSON payload { {\"key\", pair.Key}, {\"type\", pair.Value is long ? \"integer\" : (pair.Value is bool ? \"boolean\" : (pair.Value is string ? \"string\" : \"binary\"))}, {\"value\", pair.Value is byte[] bytes ? bytes.ToBase64() : pair.Value } })}, {\"fee\", 3000000}, //Arbitary fee {\"timestamp\", Timestamp.ToLong()}, {\"proofs\", new string[] { proof.ToBase58()} } // Add the signature to the JSON }; String TestNetHost = \"https://node1.testnet-0bsnetwork.com\"; var response = Http.Post(TestNetHost + \"/transactions/broadcast\", finalTransaction); // Broadcast the transaction to a public node on the network Console.Write(response); // Output the response Console.Read(); } } }","title":"Transactions"},{"location":"transactions/#transactions","text":"","title":"Transactions"},{"location":"transactions/#transaction-types","text":"Each transaction type is given an integer to represent it as follows. The transaction fee is included below too, though libraries should have these set by default. Transaction Type Name Description Fee (ZBS) 3 Issue Create a new token / asset 500.00 4 Transfer Send ZBS or Token to another address 0.05 5 ReIssue Issue more of your token 200.00 6 Burn Destroy X tokens 5.00 7 Exchange A Trade. Buy / Sell 0.20 8 Lease Start leasing to another address 5.00 9 LeaseCancel Cancel a Lease 1.00 10 CreateAlias Create an alias for your address 10 11 MassTransfer Send up to 100 Transfers in 1 transaction 0.05 12 Data Save data to the blockchain 0.03 13 SetScript Add a script to an Address 10.00 14 CustomFee Setup a Custom Fee for your Asset 50.00 15 SetAsset Set a script on an asset 10.00 16 ContractInvoke Run a contract 0.10 17 Index 18 CustomFee Extra Fee: 0.01 (In addition to fee when operating with smart assets or accounts)","title":"Transaction Types"},{"location":"transactions/#transaction-formats","text":"The below sections demonstrate the JSON transaction format that is required to make a transaction. When signing a transaction on a Node, you can exclude the signature/proofs field as the server will give you this back. Within the transaction JSON, Fee's are expressed without decimal values, so ZBS has 8 decimal places, and 100000000 represents 1 ZCL within the transaction JSON.","title":"Transaction Formats"},{"location":"transactions/#issue-reissue-transaction","text":"Issue and ReIssue take the same format apart from the type { \"senderPublicKey\":\"2M25DqL2W4rGFLCFadgATboS8EPqyWAN3DjH12AH5Kdr\", \"quantity\": 50000 \"fee\": 50000000000, \"description\":\"My New Token\", \"type\":3 / 5, \"version\":2, \"reissuable\":true, \"script\":\"base64:AQa3b8tH\", // Optional Script for 'Smart Assets' \"sender\":\"3Mz9N7YPfZPWGd4yYaX6H53Gcgrq6ifYiH7\", \"feeAssetId\":null, // When paying using custom fees \"chainId\":84, // 84 (T) for testnet 90 (Z) for mainnet \"proofs\":[\"4yjVxzrLuXUq5y2QCa2LDn1Fp9P63hPBmqDLGQCqn41EB1uZ1pys79NP81h7FxRBnZSbpNGbz1xjwckHcPAQHmFX\"], \"decimals\":2, \"name\":\"MyTestToken\" }","title":"Issue / ReIssue Transaction"},{"location":"transactions/#transfer-transaction","text":"{ \"senderPublicKey\":\"4c5K4kGeRdrnSYZ9wngQKSozikVgfxmDEuViirsyUHwd\", \"amount\":110000000 fee\":500000, \"type\":4, \"version\":2, \"attachment\":\"\", \"sender\":\"3MyT3r1S8xvKtiKnLgVNNiSAiQdnMbffBQy\", \"feeAssetId\":null, \"proofs\":[\"2KFbYWi9BJwDG9dbiJQzC9qJPpu4Ug8Ybs331fQbX9FAkEpEtrj9DKvwNG7cb2m98DV6NCoKH4MBVtGGFsnQWPV6\"], \"assetId\":null, // If we are sending an asset, null for ZBS \"recipient\":\"3MqEisFsWdhvDMAKBwZzZv4niVsfJJtxcaw\", \"feeAsset\":null }","title":"Transfer Transaction"},{"location":"transactions/#burn-transaction","text":"Burning tokens can be useful for systems where a token is used to activate or fund a service and once the service has been used the token can be burnt. { type: 6, id: 'ComWcac6FMKBT4sNNyNwDDFG8T63s3xorV4M7x8y6TVm', sender: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', senderPublicKey: '4vR9m3vFuAWqQ6zJWDeqnPCMgLsxKkz2sQcAcEjHduU', fee: 500000000, timestamp: 1561326417304, proofs: [ '3c2ao2uF2T6sxLJqHZSdAY2brjHHeUVQqNMDDJPxfh33JAyTeocnAWGt7nw6dwTB2mBEG8CimuC4BP19DCfB98YZ' ], version: 2, assetId: 'BiuhdjnH9qxgfax52zXgJw3b5ArxCdA4q8kYECqWoEYT', amount: 1, chainId: 84 }","title":"Burn Transaction"},{"location":"transactions/#exchange-transaction","text":"{ \"senderPublicKey\":\"8QUAqtTckM5B8gvcuP7mMswat9SjKUuafJMusEoSn1Gy\", \"amount\":1000000000, \"fee\":300000, \"type\":7, \"version\":2, \"sellMatcherFee\":30000, \"buyMatcherFee\":300000, \"sender\":\"3N8aZG6ZDfnh8YxS6aNcteobN8eXTWHaBBd\", \"feeAssetId\":null, \"proofs\":[\"4kBxzWXSzbM4jQbi8SmNtZeRJEwUkMzCezf8AQYeu5z124ajpKG9GVJZbHdnRWz9R1Key5opySDbKj6B4zTtZsNF\"], \"price\":90, \"id\":\"28biMwpgZVjAUk5iJnWvphaFgr8Tybwqe6s5JxGTdDWJ\", \"order2\": {\"version\":2, \"id\":\"GaCXusGNDkYZ8iciV3cuUKb7r4awESwocghJXnFyLxYk\", \"sender\":\"3MwBD8xZByEHAnwB69eexgVPAPD5ucw1Rna\",\"senderPublicKey\":\"HHonWv97CD2XXgRNbny7aCWP8amgYatCaTEthq38P1Do\",\"matcherPublicKey\":\"8QUAqtTckM5B8gvcuP7mMswat9SjKUuafJMusEoSn1Gy\", //Obtained from https://matcher.testnet-0bsnetwork.com/matcher \"assetPair\": { \"amountAsset\":\"4CFzLzP3vBHBev9GyeWm6AP7hm72qn6xELU1je5Wmq8L\", \"priceAsset\":null }, \"orderType\":\"sell\", \"amount\":10000000000, \"price\":90, \"timestamp\":1548657730301, \"expiration\":1551163330301, \"matcherFee\":300000,\"signature\":\"2uX8CedW8oPXqktAwJLm9emFArUimxcXD9pqHnd2mEWJYYJuBChzk59fzB7DVeKnczmosJa4vfAvCzqY8DSoq4Rr\",\"proofs\":[\"2uX8CedW8oPXqktAwJLm9emFArUimxcXD9pqHnd2mEWJYYJuBChzk59fzB7DVeKnczmosJa4vfAvCzqY8DSoq4Rr\"] }, \"order1\": { \"version\":2, \"id\":\"4EFqAQLW8S2Swo3dh5RZ5DXNtfQRDij7Y28RayN3vW7G\", \"sender\":\"3N5h5G6ToFR7cMMzdzR1hvUaMNuz7quCt4H\",\"senderPublicKey\":\"He5xRqcQBzk1VbdH7GP3XdGbB7dLwsvEbyLfNAbVkunJ\",\"matcherPublicKey\":\"8QUAqtTckM5B8gvcuP7mMswat9SjKUuafJMusEoSn1Gy\", //Obtained from https://matcher.testnet-0bsnetwork.com/matcher \"assetPair\": { \"amountAsset\":\"4CFzLzP3vBHBev9GyeWm6AP7hm72qn6xELU1je5Wmq8L\", \"priceAsset\":null }, \"orderType\":\"buy\", \"amount\":1000000000, \"price\":100, \"timestamp\":1548661139113, \"expiration\":1548661439111, \"matcherFee\":300000,\"signature\":\"23mzQgZgjsKBCTLRLS8ktbtP6EZx3gABT9AF63UF4nuhS1o7XJgEGby2umhijo4t8yKuw1CmZ3UVab4A6vtod3H8\",\"proofs\":[\"23mzQgZgjsKBCTLRLS8ktbtP6EZx3gABT9AF63UF4nuhS1o7XJgEGby2umhijo4t8yKuw1CmZ3UVab4A6vtod3H8\"] } }","title":"Exchange Transaction"},{"location":"transactions/#lease-transaction","text":"{ \"senderPublicKey\":\"FB5ErjREo817duEBBQUqUdkgoPctQJEYuG3mU7w3AYjc\", \"amount\":1, \"fee\":500000000, \"type\":8, \"version\":2, \"sender\":\"3Mps7CZqB9nUbEirYyCMMoA7VbqrxLvJFSB\", \"feeAssetId\":null, \"proofs\":[\"fkWj6RkV722jhv72BY6Eo5BZ6N4T8nTPcmQVmoBs14Cv53W2VfRE7C9rT1TN4CZfAW2Y2YhVFm24NGZh75eBHq4\"],\"recipient\":\"3NCKpqzSnHmXhZEmqYy4U6RUKUAJDTxWgWP\" }","title":"Lease Transaction"},{"location":"transactions/#lease-cancel","text":"{ \"senderPublicKey\":\"FB5ErjREo817duEBBQUqUdkgoPctQJEYuG3mU7w3AYjc\", \"amount\":1 \"fee\":100000000, \"type\":8, \"version\":2, \"sender\":\"3Mps7CZqB9nUbEirYyCMMoA7VbqrxLvJFSB\", \"feeAssetId\":null, \"proofs\":[\"fkWj6RkV722jhv72BY6Eo5BZ6N4T8nTPcmQVmoBs14Cv53W2VfRE7C9rT1TN4CZfAW2Y2YhVFm24NGZh75eBHq4\"],\"recipient\":\"3NCKpqzSnHmXhZEmqYy4U6RUKUAJDTxWgWP\" }","title":"Lease Cancel"},{"location":"transactions/#create-alias","text":"{ \"senderPublicKey\":\"BVv1ZuE3gKFa6krwWJQwEmrLYUESuUabNCXgYTmCoBt6\", \"sender\":\"3N8S4UtauvDAzpLiaRyDdHn9muexWHhBP4D\", \"feeAssetId\":null, \"proofs\":[\"22QJfRKX7kUQt4qjdnUqZAnhqukqhnofE27uvP8Q5xnBf8M6PCNtWVGq2ngm6m7Voe7duys59D1yU9jhKrmdXDCe\"], \"fee\":1000000000, \"alias\":\"91f452553298770f\", \"id\":\"AD7KmXwoVNc2fXsmaxsHsrnT1tfPF3HsWYtfjFijVsvM\", \"type\":10, \"version\":2 }","title":"Create Alias"},{"location":"transactions/#mass-transfer","text":"{ type: 11, id: '48Dn8uK95jL8iZqv81gqv7PxJtbrZihjmg1Zdcs1428P', sender: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', senderPublicKey: '4vR9m3vFuAWqQ6zJWDeqnPCMgLsxKkz2sQcAcEjHduU', fee: 10000000, timestamp: 1561326259593, proofs: [ 'YxmbijFFmNM9goWMoxxcPtHM36TKFVrMfC5i9yZEPtZiqoDZ13M3kQJBw557bi728vmR9ydFYZ847gdoisbCVnM' ], version: 1, assetId: null, attachment: '', transferCount: 2, totalAmount: 2, transfers: [ { recipient: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', amount: 1 }, { recipient: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', amount: 1 } ] }","title":"Mass Transfer"},{"location":"transactions/#data","text":"{ type: 12, id: '3d8fQKQ8Va43vvVzbKJChMrPzQDNgLBH9GaQw23YhdZC', sender: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', senderPublicKey: '4vR9m3vFuAWqQ6zJWDeqnPCMgLsxKkz2sQcAcEjHduU', fee: 3000000, timestamp: 1561326312175, proofs: [ 'mWVbzSuomwiaowrNLBhEFcZE6dfHhK1tYWrqQZ124mum8MJuoksuqVZUjaRUW7rwLw4cEc33unKTzYP4X9ftRu9' ], version: 1, data: [ { key: 'integerVal', type: 'integer', value: 1 }, { key: 'booleanVal', type: 'boolean', value: true }, { key: 'stringVal', type: 'string', value: 'hello' }, { key: 'binaryVal', type: 'binary', value: 'base64:AQIDBA==' } ] }","title":"Data"},{"location":"transactions/#setscript","text":"","title":"SetScript"},{"location":"transactions/#set-asset","text":"","title":"Set Asset"},{"location":"transactions/#invoke-script","text":"","title":"Invoke Script"},{"location":"transactions/#index","text":"{ type: 4, id: '8LjTjtAqQscTk5o3VuzViyp5Dk3dPZ9W26ezHUEyi2LW', sender: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', senderPublicKey: '4vR9m3vFuAWqQ6zJWDeqnPCMgLsxKkz2sQcAcEjHduU', fee: 5000000, timestamp: 1561326556314, proofs: [ '5H4KDmjYh5tfe7iurVxyZZnKGwcVrproBJs83kLCgvxUi9bn6S1yiLmnrCsD5Zaijm7eJgvTaTZnS6fdx7aW8xKp' ], version: 2, recipient: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', assetId: null, feeAssetId: null, feeAsset: null, amount: 1, attachment: '' }","title":"Index"},{"location":"transactions/#custom-fees","text":"{ type: 14, id: 'HfEnBX9PBkTpNLs5BgxvqmrPQkowb9dogMcSFSSZg9Vq', sender: '3NCGfpFCVCmMSgCSct8BhExjRZ3E8i83Goo', senderPublicKey: '4vR9m3vFuAWqQ6zJWDeqnPCMgLsxKkz2sQcAcEjHduU', fee: 5000000000, timestamp: 1561328515891, proofs: [ 'Qe81c41WbSDwV1wXRVKZK9ze7kPhE5B5wSRB96ZsZ21ZbZ6hSq89accLdHH1gsZXQvC2WphL1VLKNYG1DVkWZwF' ], version: 1, assetId: 'BiuhdjnH9qxgfax52zXgJw3b5ArxCdA4q8kYECqWoEYT', minSponsoredAssetFee: 100 }","title":"Custom Fees"},{"location":"transactions/#signing-transactions","text":"Signing transactions manually is quite complex, and usually its best to use a library to do so, however if you find you dont have a library available for your platform of choice, you may need to do it manually. The process involves concatenting the byte values of fields from the transaction to create a long byte array, and signing this using Curve25519 and your private key, and inserting this into the transaction payload. Rather than include excessive details here on how to do that, the below code sample in C Sharp should be readable enough to understand how the process works, and you can also examine the code of our other libraries as they are all open source. If you need specific details or guidance, please do contact us using the details on the Front Page using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Security.Cryptography; using System.Numerics; using DictionaryObject = System.Collections.Generic.Dictionary<string, object>; using org.whispersystems.curve25519.csharp; using System.Reflection; using org.whispersystems.curve25519; using System.IO; using Program; namespace ZbsSignAndBroadcastDataTransaction { class Program { /// <summary> /// This is a raw demonstration of a Data transaction. It's purpose is to save data to the blockchain (Variable TransactionData) - The signing procedure is demonstrated below. /// </summary> // 3MqSRBfLsTzXssscX8crUH88zJegvyrd5WK // Seed Phrase: despair olive coconut design rubber proud silver rotate glow gloom extra income effort about summer // Private Key: Bq6dvj1v48EAyS34Nu6bZS7tWtaxgQnChQrJvxr5x1pM // Public Key: 7cgFXWXTGXemR2yHq1MYx8o7jVKq6Y4Y5bTyaJ478aeG // Replenish Balance: https://explorer.testnet-0bsnetwork.com/faucet private static readonly Curve25519 Cipher = Curve25519.getInstance(Curve25519.BEST); static void Main(string[] args) { byte Version = 1; byte TxType = 12; byte[] SenderPrivateKey; byte[] SenderPublicKey; byte[] transactionBytes; DateTime Timestamp = DateTime.UtcNow; SenderPrivateKey = Base58.Decode(\"Bq6dvj1v48EAyS34Nu6bZS7tWtaxgQnChQrJvxr5x1pM\"); // These are obtained from the client. X25519 Keys SenderPublicKey = Base58.Decode(\"7cgFXWXTGXemR2yHq1MYx8o7jVKq6Y4Y5bTyaJ478aeG\"); var TransactionData = new DictionaryObject { { \"test num\", (long)1 }, { \"test true\", true }, { \"test bytes\", new byte[] { 1, 2, 3, 4, 5}}, { \"test string\", \"Hello!\"} }; // To create a signature, we create a byte array. using (var stream = new MemoryStream()) using (var writer = new BinaryWriter(stream)) { writer.Write(TxType); // First we add the Transaction Type (Its a number.. 12 is Data transaction) writer.Write(Version); // Transaction version is set to 1 writer.Write(SenderPublicKey); writer.WriteShort((short)TransactionData.Count); // Next we set the number of data items we are sending, in this case, theres 4 (TransactionData) foreach (var pair in TransactionData) // For each data item we need to add its Length, Key and its value { var key = Encoding.UTF8.GetBytes(pair.Key); writer.WriteShort((short)key.Length); writer.Write(key); writer.WriteObject(pair.Value); } writer.WriteLong(Timestamp.ToLong()); writer.WriteLong(3000000); //Arbitary fee transactionBytes = stream.ToArray(); } // Next we take the byte array and sign it to generate a Proof. var proof = Cipher.calculateSignature(SenderPrivateKey, transactionBytes); // And finally, create a JSON payload to broadcast the transaction to the network var finalTransaction = new DictionaryObject { {\"type\", (byte) 12}, {\"version\", Version}, {\"senderPublicKey\", SenderPublicKey.ToBase58() }, {\"sender\", \"3MqSRBfLsTzXssscX8crUH88zJegvyrd5WK\" }, {\"data\", TransactionData.Select(pair => new DictionaryObject // Add each data entry to the JSON payload { {\"key\", pair.Key}, {\"type\", pair.Value is long ? \"integer\" : (pair.Value is bool ? \"boolean\" : (pair.Value is string ? \"string\" : \"binary\"))}, {\"value\", pair.Value is byte[] bytes ? bytes.ToBase64() : pair.Value } })}, {\"fee\", 3000000}, //Arbitary fee {\"timestamp\", Timestamp.ToLong()}, {\"proofs\", new string[] { proof.ToBase58()} } // Add the signature to the JSON }; String TestNetHost = \"https://node1.testnet-0bsnetwork.com\"; var response = Http.Post(TestNetHost + \"/transactions/broadcast\", finalTransaction); // Broadcast the transaction to a public node on the network Console.Write(response); // Output the response Console.Read(); } } }","title":"Signing Transactions"},{"location":"tutorials/","text":"Tutorials ... More Coming Soon! ... Smart Contract 1. Creating and deploying a script manually The idea of a Smart Account is the following: Before the transaction is submitted to be included in the next block, the account checks if the transaction meets certain requirements, defined in a script . The script is attached to the account so the account can validate every transaction before confirming it. In this example, we're going to create and deploy a simple 2 of 2 MultiSig example. Example Assumptions: We assume that we have our own node. We want to set up a script for an account in order to implement the smart account idea. we assume that we have three generated addresses: 3MxjWXEUcVCeiaEUqNcorB5HxSpLsgJCGxE - Alice's account. 3MqGVvfgqdqqU6P9mTAsLSxyRoRjrHF18Mf - Bob's account. 3N7H4jTBMKtZfNCY86K2ND1rWcvFsGjDT3X - Shared account. 1.1 How to Create a script The idea here is to create a script and attach it to the account so this account can : Check if the transaction meets certain requirements which is defined in the script. Validate the transaction. Confirm the transaction and broadcast it to the blockchain network. Now let's Start our 2 of 2 MultiSig Example: Use our IDE to write your script (you can find some script examples there) For this example we will use the following script: In the first two lines, we defined 2 public keys encoded in base58 for both alice and bob. After that, users gather 2 public keys in proofs[0] and proofs[1]. The account is funded by the team members and after that, when 2 of 3 team members decide to spend money, they provide their signatures in a single transaction. The Smart account script, using sigVerify function, validates these signatures with proofs and if 2 of 2 are valid then the transaction is valid too, else the transaction does not pass to the blockchain. let alicePubKey = base58'Ey6Z9XkWsvG8JZwyxhkTjydRcGp1wg6rbC3AYcxq7Efr' let bobPubKey = base58'5PvhyouzHn2Pcev56oBvwpnsGK5fEu1dA8fM2nJQM4HR' let aliceSigned = if(sigVerify(tx.bodyBytes, tx.proofs[0], alicePubKey)) then 1 else 0 let bobSigned = if(sigVerify(tx.bodyBytes, tx.proofs[1], bobPubKey )) then 1 else 0 aliceSigned + bobSigned == 2 Switch to the BINARY tab. Click on COPY TO CLIPBOARD button. A compiled Base64-encoded script should be copied into your clipboard as shown below (this step will be required later). 5Xt9H8mHtikSytHF72xAU3NJwDydxXYMMhmWiNVLbYdBRQ3FHXksc8kW8tKFm3fGto1EwTt4YSybEUrpT2yB71hCvUS3WxWfsC4PxU7 oTGt687w8T195NVeMPUqdWeHT5BwVrsoFkXF5SuMEGTaB4RyP43ygfTCNNdWauiV7guKmSvH3V2dFpK1HvhVPBjG1QafJ63Awp5qLzQ orFAbBVxgfqFLk6c99vrHCHpdjjiPv3vMN7FWLFrMPhGZbzBdyqQ8pCy1dkadxdkAytxZ3AUszTM2cfREgh9QjVVtcody7VsxDsbTPv uETHgcrk96jY7Pzft2nE7W9VF3EcGXJ7VDSKX5ucVpkZwugJCa4SgAkBGPnCxmUf3RmrAUuWaCQPMPfUyayyWfZ4wDguz74cLuDpmU3 htVHbcuVQ7KrU55b5w4QFZyLDzHvgXXtCiqMEKFTrepcdy2LjA55D63EUhmQgVA6yqQbmLU6WKFabEsXETBRtzmCqPmGeB4iQXS16rB WBMHK214mYRoxdAH3zvKyWQcqndnWETd59mCEGkRjB9UUL6vmCF1ZQCSytdJKgyRhRQ7pzxxa5iL92hGSCRdw7yFWAv77aCV3ujJjqs SAtDTKwqmdqJpWtBWYLEy6cfaTTKCQFNH2Lnj2DYgaFRWETGQVQpMMVYFKkk 1.2 Attaching a script to account Now let's prepare a JSON request to sign a SetScriptTransaction for the shared account with a given script: { \"type\": 13, \"version\": 1, \"sender\": \"3N7H4jTBMKtZfNCY86K2ND1rWcvFsGjDT3X\", \"fee\": 1000000000, \"script\": \"<script>`\" } Send it to [/transactions/sign]: $ curl -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' \\ --header 'X-API-Key: <it is a secret>' \\ -d '{ \"type\": 13, \"version\": 1, \"sender\": \"3N7H4jTBMKtZfNCY86K2ND1rWcvFsGjDT3X\", \"fee\": 100000, \\ \"script\": \"<script>\" }' 'https://nodeaddress/transactions/sign' and receive a JSON ready to broadcast: { \"type\": 13, \"id\": \"8w7yauNiENsJP8oDUpVEfiAzyEzMKoXbJEqS26Ht99mg\", \"sender\": \"3N7H4jTBMKtZfNCY86K2ND1rWcvFsGjDT3X\", \"senderPublicKey\": \"66xdGznqt2AVLMZRHme9vFPC6cvN4yV95wRWPfTus3Qe\", \"fee\": 100000, \"timestamp\": 1525797758819, \"proofs\": [ \"4Ro4e4UrsVkaFbHtu96qZwHAdf8N4TtpjSGik9kRusmmYKCxicdsEqcgQrYden36nurqhY9EBkTKwD499kAi5rxe\" ], \"version\": 1, \"script\": \"<script>\" } Then we [broadcast] a prepared request: $ curl -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' \\ --header 'X-API-Key: <it is a secret>' \\ -d '{ \"type\": 13, \"id\": \"8w7yauNiENsJP8oDUpVEfiAzyEzMKoXbJEqS26Ht99mg\", \"sender\": \"3N7H4jTBMKtZfNCY86K2ND1rWcvFsGjDT3X\", \\ \"senderPublicKey\": \"66xdGznqt2AVLMZRHme9vFPC6cvN4yV95wRWPfTus3Qe\", \"fee\": 100000, \"timestamp\": 1525797758819, \\ \"proofs\": [ \"4Ro4e4UrsVkaFbHtu96qZwHAdf8N4TtpjSGik9kRusmmYKCxicdsEqcgQrYden36nurqhY9EBkTKwD499kAi5rxe\" ], \\ \"version\": 1, \"script\": \"<script>\" }' \\ 'https://example.org/transactions/broadcast' And check it was applied: $ curl http://example.org/addresses/scriptInfo/3N7H4jTBMKtZfNCY86K2ND1rWcvFsGjDT3X { \"address\" : \"3N7H4jTBMKtZfNCY86K2ND1rWcvFsGjDT3X\", \"script\" : \"<script>\", \"scriptText\" : \"<scriptText>\", \"complexity\" : 27, \"extraFee\" : 400000 } where <scriptText> is a String representation of compiled <script> (expression tree) Fine! Now we able to make transfers from this account.","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"... More Coming Soon! ...","title":"Tutorials"},{"location":"tutorials/#smart-contract","text":"","title":"Smart Contract"},{"location":"tutorials/#1-creating-and-deploying-a-script-manually","text":"The idea of a Smart Account is the following: Before the transaction is submitted to be included in the next block, the account checks if the transaction meets certain requirements, defined in a script . The script is attached to the account so the account can validate every transaction before confirming it. In this example, we're going to create and deploy a simple 2 of 2 MultiSig example. Example Assumptions: We assume that we have our own node. We want to set up a script for an account in order to implement the smart account idea. we assume that we have three generated addresses: 3MxjWXEUcVCeiaEUqNcorB5HxSpLsgJCGxE - Alice's account. 3MqGVvfgqdqqU6P9mTAsLSxyRoRjrHF18Mf - Bob's account. 3N7H4jTBMKtZfNCY86K2ND1rWcvFsGjDT3X - Shared account.","title":"1. Creating and deploying a script manually"},{"location":"tutorials/#11-how-to-create-a-script","text":"The idea here is to create a script and attach it to the account so this account can : Check if the transaction meets certain requirements which is defined in the script. Validate the transaction. Confirm the transaction and broadcast it to the blockchain network. Now let's Start our 2 of 2 MultiSig Example: Use our IDE to write your script (you can find some script examples there) For this example we will use the following script: In the first two lines, we defined 2 public keys encoded in base58 for both alice and bob. After that, users gather 2 public keys in proofs[0] and proofs[1]. The account is funded by the team members and after that, when 2 of 3 team members decide to spend money, they provide their signatures in a single transaction. The Smart account script, using sigVerify function, validates these signatures with proofs and if 2 of 2 are valid then the transaction is valid too, else the transaction does not pass to the blockchain. let alicePubKey = base58'Ey6Z9XkWsvG8JZwyxhkTjydRcGp1wg6rbC3AYcxq7Efr' let bobPubKey = base58'5PvhyouzHn2Pcev56oBvwpnsGK5fEu1dA8fM2nJQM4HR' let aliceSigned = if(sigVerify(tx.bodyBytes, tx.proofs[0], alicePubKey)) then 1 else 0 let bobSigned = if(sigVerify(tx.bodyBytes, tx.proofs[1], bobPubKey )) then 1 else 0 aliceSigned + bobSigned == 2 Switch to the BINARY tab. Click on COPY TO CLIPBOARD button. A compiled Base64-encoded script should be copied into your clipboard as shown below (this step will be required later). 5Xt9H8mHtikSytHF72xAU3NJwDydxXYMMhmWiNVLbYdBRQ3FHXksc8kW8tKFm3fGto1EwTt4YSybEUrpT2yB71hCvUS3WxWfsC4PxU7 oTGt687w8T195NVeMPUqdWeHT5BwVrsoFkXF5SuMEGTaB4RyP43ygfTCNNdWauiV7guKmSvH3V2dFpK1HvhVPBjG1QafJ63Awp5qLzQ orFAbBVxgfqFLk6c99vrHCHpdjjiPv3vMN7FWLFrMPhGZbzBdyqQ8pCy1dkadxdkAytxZ3AUszTM2cfREgh9QjVVtcody7VsxDsbTPv uETHgcrk96jY7Pzft2nE7W9VF3EcGXJ7VDSKX5ucVpkZwugJCa4SgAkBGPnCxmUf3RmrAUuWaCQPMPfUyayyWfZ4wDguz74cLuDpmU3 htVHbcuVQ7KrU55b5w4QFZyLDzHvgXXtCiqMEKFTrepcdy2LjA55D63EUhmQgVA6yqQbmLU6WKFabEsXETBRtzmCqPmGeB4iQXS16rB WBMHK214mYRoxdAH3zvKyWQcqndnWETd59mCEGkRjB9UUL6vmCF1ZQCSytdJKgyRhRQ7pzxxa5iL92hGSCRdw7yFWAv77aCV3ujJjqs SAtDTKwqmdqJpWtBWYLEy6cfaTTKCQFNH2Lnj2DYgaFRWETGQVQpMMVYFKkk","title":"1.1 How to Create a script"},{"location":"tutorials/#12-attaching-a-script-to-account","text":"Now let's prepare a JSON request to sign a SetScriptTransaction for the shared account with a given script: { \"type\": 13, \"version\": 1, \"sender\": \"3N7H4jTBMKtZfNCY86K2ND1rWcvFsGjDT3X\", \"fee\": 1000000000, \"script\": \"<script>`\" } Send it to [/transactions/sign]: $ curl -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' \\ --header 'X-API-Key: <it is a secret>' \\ -d '{ \"type\": 13, \"version\": 1, \"sender\": \"3N7H4jTBMKtZfNCY86K2ND1rWcvFsGjDT3X\", \"fee\": 100000, \\ \"script\": \"<script>\" }' 'https://nodeaddress/transactions/sign' and receive a JSON ready to broadcast: { \"type\": 13, \"id\": \"8w7yauNiENsJP8oDUpVEfiAzyEzMKoXbJEqS26Ht99mg\", \"sender\": \"3N7H4jTBMKtZfNCY86K2ND1rWcvFsGjDT3X\", \"senderPublicKey\": \"66xdGznqt2AVLMZRHme9vFPC6cvN4yV95wRWPfTus3Qe\", \"fee\": 100000, \"timestamp\": 1525797758819, \"proofs\": [ \"4Ro4e4UrsVkaFbHtu96qZwHAdf8N4TtpjSGik9kRusmmYKCxicdsEqcgQrYden36nurqhY9EBkTKwD499kAi5rxe\" ], \"version\": 1, \"script\": \"<script>\" } Then we [broadcast] a prepared request: $ curl -X POST --header 'Content-Type: application/json' --header 'Accept: application/json' \\ --header 'X-API-Key: <it is a secret>' \\ -d '{ \"type\": 13, \"id\": \"8w7yauNiENsJP8oDUpVEfiAzyEzMKoXbJEqS26Ht99mg\", \"sender\": \"3N7H4jTBMKtZfNCY86K2ND1rWcvFsGjDT3X\", \\ \"senderPublicKey\": \"66xdGznqt2AVLMZRHme9vFPC6cvN4yV95wRWPfTus3Qe\", \"fee\": 100000, \"timestamp\": 1525797758819, \\ \"proofs\": [ \"4Ro4e4UrsVkaFbHtu96qZwHAdf8N4TtpjSGik9kRusmmYKCxicdsEqcgQrYden36nurqhY9EBkTKwD499kAi5rxe\" ], \\ \"version\": 1, \"script\": \"<script>\" }' \\ 'https://example.org/transactions/broadcast' And check it was applied: $ curl http://example.org/addresses/scriptInfo/3N7H4jTBMKtZfNCY86K2ND1rWcvFsGjDT3X { \"address\" : \"3N7H4jTBMKtZfNCY86K2ND1rWcvFsGjDT3X\", \"script\" : \"<script>\", \"scriptText\" : \"<scriptText>\", \"complexity\" : 27, \"extraFee\" : 400000 } where <scriptText> is a String representation of compiled <script> (expression tree) Fine! Now we able to make transfers from this account.","title":"1.2 Attaching a script to account"}]}